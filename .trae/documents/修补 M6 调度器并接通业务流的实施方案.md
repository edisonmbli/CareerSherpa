## 总体目标

* 使 M6（Upstash QStash + Upstash Redis）严格符合文档 2.2.3 与 2.3.0：按任务类型与付费/免费队列进行隔离、对模型维度做并发控制、在生产者侧做队列背压、工人侧严格释放计数与锁，并为 SSE 任务提供稳定的事件通道与超时规避。

## 现状回顾（代码指针）

* 生产者：`lib/queue/producer.ts` 统一推送到 `/api/worker/{stream|batch}/[service]`，未按 `QueueId` 分发（35, 94–105）。

* 守卫：`lib/worker/common.ts` 的 `enterGuards/exitGuards` 负责锁与背压（61–93），事件通道 `cs:events:{userId}:{serviceId}:{taskId}`（53–59）。

* 锁与计数器：`lib/concurrencyLock.ts`（8–19, 30–42）、`lib/redis/counter.ts`（63–101, 109–121）。

* 流式工人：`app/api/worker/stream/[service]/route.ts` 内联 LCEL 流，未复用 `lib/llm/service.ts:runStreamingLlmTask`。

* 队列路由表：`lib/llm/task-router.ts` 提供 `QueueId` 与 `modelId`，但生产者与工人未消费 `queueId` 做实际隔离。

* SSE 桥：`components/dev/SseStreamViewer.tsx` + `app/api/sse-stream/route.ts`（稳定心跳与 Redis Streams 缓冲）。

* 缺口：未接入真实 Server Actions（`uploadResumeAction/createServiceAction/...`）。

## 差距与修补要点

1. 队列分级隔离未落地：生产者与工人统一入口，未按 `QueueId`（付费/免费/视觉）拆路由。
2. 模型维度并发控制缺失：存在 `DEEPSEEK_MAX_WORKERS/GLM_MAX_WORKERS` 配置但未在守卫层按 `modelId`实施。
3. 背压位置偏离：当前由工人侧 `enterGuards` 进行；应在生产者侧入队前做 `bumpPending` 拦截。
4. 流式逻辑分散：工人路由内联 LCEL，未统一复用 `lib/llm/service.ts` 的流式执行入口。
5. 业务入口缺失：关键 Server Actions 未接通调度器，导致开发页能跑通，生产流未接入。

## 技术实施方案

### 阶段 1：路由与队列隔离

* 在生产者根据 `decision.queueId` 改造发布目标：将 QStash `url` 改为分层路径（如 `/api/worker/paid/stream/...`、`/api/worker/free/batch/...`、`/api/worker/paid/vision/...`）。

* 在 `app/api/worker/**` 下新增/整理路由结构，按 `paid/free/vision` + `stream/batch` 组合拆分入口。将 `enterGuards/exitGuards` 继续复用。

### 阶段 2：模型并发锁

* 在 `enterGuards` 前插入按 `modelId` 的并发锁：锁键示例 `lock:model:{modelId}:{tier}`（tier=paid/free）。

* 并发策略：`SET NX` 拿槽，并配合 `INCR` 计数与 `EXPIRE` TTL；达到阈值（来自 `ENV`）返回 `429` 并发布 `backpressure` 事件。

* 在 `exitGuards` 中释放模型并发计数与锁。

### 阶段 3：生产者侧背压

* 在 `lib/queue/producer.ts` 入队前调用 `bumpPending('queue:{queueId}', ttlSec, maxSize)`；超过阈值直接返回错误与 `Retry-After`。

* 将 `counterKey` 传入消息体，工人 `finally` 中 `decPending(counterKey)` 与释放锁保持一致。

### 阶段 4：统一流式执行入口

* 流式工人改用 `lib/llm/service.ts:runStreamingLlmTask`（保留 LCEL），事件发布统一走 `publishEvent` 合并批次与 Streams 写入，减少分散逻辑。

### 阶段 5：接通 Server Actions（M8/M9 前置）

* 新增并接通：`uploadResumeAction`、`uploadDetailedResumeAction`、`createServiceAction`（文本/图片分支）、`customizeResumeAction`、`generateInterviewTipsAction`。

* 每个 Action：`getOrCreateQuota` → 队列选择（付费/免费）→ 生产者背压检查 →（有配额则原子扣费）→ QStash 推送 → 立即返回 `taskId/isFree/stream`。

### 阶段 6：配置与一致性

* 将锁模块迁移或别名到 `lib/redis/lock.ts`（或更新文档）以保持一致。

* 落地 `ENV` 中的并发与队列大小引用：`getConcurrencyConfig()` 给守卫与生产者统一读取。

### 阶段 7：测试与验收

* 单元测试：

  * 背压：生产者超阈值返回 429 并不发布。

  * 并发锁：同模型并发超限被拒；释放后可继续。

  * 事件发布：`token_batch` 合并与 `done` 终止写 Streams。

* E2E（本地）：

  * 推 3 个 text（并发=1）串行、2 个 vision（并发=2）并行，计数器归零。

  * 一个付费、一个免费任务分别进入对应路由并正确限流。

* 开发页验证：`/(dev)/sse` 能在所有队列组合下正常流式与完成。

## 交付物

* 改造的生产者与按队列拆分的工人路由。

* 守卫层的模型并发锁与生产者侧队列背压。

* 统一流式执行入口与事件发布。

* 补齐的 Server Actions（带原子化扣费与降级标记）。

* 测试用例与本地 E2E 验收日志。

## 里程碑

* Milestone A（队列隔离+模型并发+生产者背压）：完成路由与守卫改造，跑通开发页。

* Milestone B（统一流层+Server Actions）：接通业务入口，开发页与页面流共同通过。

* Milestone C（测试与验收）：补全测试，完成 E2E 串并行、付费/免费分流与 SSE 稳定性验证。

## 风险与回避

* QStash 路由拆分后需要重新配置签名校验与 URL；通过共用 `verifySignatureAppRouter` 与严格路径校验避免误入。

* 并发锁需考虑工人异常退出的泄漏；使用 `EXPIRE TTL` 与 `finally` 兜底释放避免悬挂锁。

* 生产者背压与工人背压要保证计数一致；通过传递统一 `counterKey` 并在 `finally` 释放。

