### M9 + M10 落地指南 (致 Agentic Coder)

**里程碑目标**：完成应用的核心价值闭环。实现 `Workbench` 的 `job_match` (M9)、`customize` (M10)、`interview` (M10) 三大服务流，并交付配套的“历史记录查看”、“Markdown 编辑器”和“金币历史”功能。

**核心规范**：

- **架构**：严格遵循 M6 敲定的“**轮询/流式混合握手**”架构。
- **UI/UX**：严格遵循 M3（设计系统）和 M8（“五态”交互指南）。
- **规则**：严格遵循 `project rules`（Server Actions, DAL, Zod, Analytics）。

---

#### 任务 1：(AI IDE) 升级 Workers & DAL (M9 + M10)

**目标**：“教会” M6 的 Workers 处理 M9 和 M10 的新任务（`job_summary`, `customize`, `interview`），并创建 M10 所需的 DAL。

**1.1: (AI IDE) 升级 `batch-processor` Worker**

- **文件**：`app/api/worker/batch-processor/route.ts`
- **动作**：AI IDE 必须**重构** M8 的 `handler`，将其拆分为一个“路由”`switch` 和“执行器”`executor`，并**添加 `job_summary` 和 `customize` 逻辑**。

<!-- end list -->

```typescript
// AI IDE: Overwrite app/api/worker/batch-processor/route.ts
import { NextResponse } from 'next/server'
import { verifySignatureEdge } from '@upstash/qstash/dist/nextjs'
// (Import M2, M4, M5, M6, M7 modules...)
import { runStructuredLlmTask } from '@/lib/llm/service'
import {
  decrementQueueCounter,
  acquireConcurrencyLock,
  releaseConcurrencyLock,
} from '@/lib/kv' // (M6 假设已导出)
import { QStashPayload } from '@/lib/queue/producer'
import { db } from '@/lib/prisma'
import { addQuota } from '@/lib/dal/quotas'
import { trackEvent } from '@/lib/analytics'
import { queryRag } from '@/lib/rag/retriever' // M5

export const runtime = 'edge'

// M9 任务链：Task B (Summary)
async function handleJobSummary(payload: QStashPayload) {
  const { modelId, locale, context } = payload
  const { userId, serviceId, taskId, rawText } = context

  const summary = await runStructuredLlmTask(
    modelId as any,
    'job_summary',
    locale,
    { job_text: rawText },
    { userId, serviceId }
  )

  await db.job.update({
    where: { id: taskId },
    data: { jobSummaryJson: summary as any, status: 'COMPLETED' },
  })

  // (M9 关键) 更新 Service 状态，触发前端轮询 UI 变化
  await db.service.update({
    where: { id: serviceId },
    data: {
      // 更新 Match 状态，告知前端 OCR/Summary 已完成
      match: {
        update: { where: { serviceId }, data: { status: 'MATCH_PENDING' } },
      },
    },
  })
}

// M10 任务：Customize
async function handleCustomize(payload: QStashPayload) {
  const { modelId, locale, context } = payload
  const { userId, serviceId, taskId } = context

  // (M5) RAG + (M1) DB
  const service = await db.service.findUniqueOrThrow({
    where: { id: serviceId },
    include: { resume: true, job: true, match: true },
  })

  const ragContext = await queryRag(
    service.job!.jobSummaryJson as string, // (简化)
    locale,
    ['customize'] // (M5 规范)
  )

  const structuredResult = await runStructuredLlmTask(
    modelId as any,
    'resume_customize',
    locale,
    {
      rag_context: ragContext,
      resume_text: service.resume!.originalText,
      job_summary_json: JSON.stringify(service.job!.jobSummaryJson),
      match_analysis_json: JSON.stringify(service.match!.matchSummaryJson),
    },
    { userId, serviceId }
  )

  await db.customizedResume.update({
    where: { id: taskId },
    data: {
      markdownContent: (structuredResult as any).customized_resume_markdown,
      status: 'COMPLETED',
    },
  })
}

// ... (M8 的 handleResumeSummary, handleDetailedResumeSummary 保持不变) ...

// M6 路由 Handler (已重构)
async function handler(request: Request) {
  const payload = (await request.json()) as QStashPayload
  const { taskTemplateId, modelId, context } = payload
  const { userId, taskId, queueId } = context

  let lockKey: string | null = null
  const startTime = Date.now()

  try {
    const { success, lockKey: acqKey } = await acquireConcurrencyLock(
      modelId,
      5
    ) // (M6.1)
    if (!success) {
      return NextResponse.json(
        { error: 'Concurrency limit reached' },
        { status: 429 }
      )
    }
    lockKey = acqKey

    // --- M9/M10 任务路由 ---
    switch (taskTemplateId) {
      case 'resume_summary':
        await handleResumeSummary(payload) // M8
        break
      case 'detailed_resume_summary':
        await handleDetailedResumeSummary(payload) // M8
        break
      case 'job_summary':
        await handleJobSummary(payload) // M9
        break
      case 'resume_customize':
        await handleCustomize(payload) // M10
        break
      default:
        throw new Error(`[BatchWorker] Unknown task: ${taskTemplateId}`)
    }
    // --- 结束 ---

    trackEvent(userId, 'TASK_COMPLETED', {
      /*...*/
    }) // (M7)
    return NextResponse.json({ success: true })
  } catch (error) {
    // (M10) 失败处理 (需更新所有表)
    await db.customizedResume.updateMany({
      where: { id: taskId, status: 'PENDING' },
      data: { status: 'FAILED' },
    })
    await db.job.updateMany({
      where: { id: taskId, status: 'PENDING' },
      data: { status: 'FAILED' },
    })
    // ... (M8 的 resume/detailedResume FAILED 状态) ...

    // (M2) 金币返还
    // ...
    trackEvent(userId, 'TASK_FAILED', {
      /*...*/
    }) // (M7)
    return NextResponse.json(
      { error: (error as Error).message },
      { status: 500 }
    )
  } finally {
    if (lockKey) await releaseConcurrencyLock(modelId, lockKey) // (M6.1)
    if (queueId) await decrementQueueCounter(queueId) // (M6.2)
  }
}
export const POST = verifySignatureEdge(handler)
```

**1.2: (AI IDE) 升级 `stream-processor` Worker**

- **文件**：`app/api/worker/stream-processor/route.ts`
- **动作**：AI IDE 必须**重构**此文件，添加 M9 (`job_match`) 和 M10 (`interview_prep`) 的 RAG 和 DB 逻辑。
  - (AI IDE: 逻辑与 `batch-processor` 类似，`handler` 中使用 `switch (taskTemplateId)`。`case 'job_match'` 和 `case 'interview_prep'` 必须：
  <!-- end list -->
  1.  从 DB 获取 `service` 上下文。
  2.  调用 `queryRag()` (M5)。
  3.  准备 `variables`。
  4.  调用 `runStreamingLlmTask` (M4)。
  5.  `onStreamEnd` 回调中，**必须** `JSON.parse(output)`，用 `Zod` 验证，并写回 `db.match` 或 `db.interview` 表。)

**1.3: (AI IDE) 新建 `ocr-processor` Worker (M9.3)**

- **文件**：`app/api/worker/ocr-processor/route.ts`
- **动作**：AI IDE 必须**新建**此文件。
  - **(M6)**：遵循 `batch-processor` 的完整模板（`verifySignature`, `acquireLock`, `decrementCounter`, `try/catch/finally`）。
  - **(M4)**：调用 M4 `getModel(ModelId.GLM_4_VISION)`（需要 `LangChain` 的 `HumanMessage` 传入 Base64 Image）。
  - **(M1)**：将 `raw_text` 写回 `db.job` 表。
  - **(M6)**：**(任务链核心)** 在 `try` 块的**末尾**，**必须**调用 `pushTaskToQueue`，将 `job_summary` 任务（Task B） 推送到 `batch-processor` 队列。

**1.4: (AI IDE) M10 DAL for Billing**

- **文件**：`lib/dal/billing.ts`
- **动作**：AI IDE 必须**新建**此文件，用于 M10 的 `Profile Page`。

  ```typescript
  // AI IDE: Create this file at lib/dal/billing.ts
  import { db } from '@/lib/prisma'

  // M10.3：获取金币使用历史
  export const getQuotaHistory = (userId: string) => {
    return db.llmUsageLog.findMany({
      where: { userId: userId, isSuccess: true },
      select: {
        createdAt: true,
        taskTemplateId: true,
        cost: true,
      },
      orderBy: { createdAt: 'desc' },
      take: 20,
    })
  }
  ```

---

#### 任务 2：(AI IDE) `createServiceAction` (M9.4)

- **目标**：实现 M9 的“指挥塔” Server Action。
- **文件**：`lib/actions/service.actions.ts`
- **动作 (AI IDE)**：AI IDE 必须**新建**此文件，它必须**完美实现** M6 `#2.C` 中定义的“**跨队列复杂任务**”逻辑。

<!-- end list -->

```typescript
// AI IDE: Create this file at lib/actions/service.actions.ts
'use server'
// (Import all M1-M7 modules: db, withAuth, quotaDAL, getTaskRouting, getJobVisionTaskRouting, incrementQueueCounter, pushTaskToQueue, trackEvent, parsePdfFromFormData, ...)
import { db } from '@/lib/prisma'
import { withAuth } from '@/lib/auth/wrapper'
import * as quotaDAL from '@/lib/dal/quotas'
import { getTaskRouting, getJobVisionTaskRouting } from '@/lib/llm/task-router'
import { incrementQueueCounter, decrementQueueCounter } from '@/lib/kv/counter'
import { pushTaskToQueue, QStashPayload } from '@/lib/queue/producer'
import { trackEvent } from '@/lib/analytics'
// (M9 TODO: 需新建 'parseImageFromFormData' 或 M8 的 file-processor 需升级)

// ... (zod schema, ActionInput, ActionOutput types from M8 guide) ...
type ActionInput = { formData: FormData; locale: Locale }
type ActionOutput = {
  /* ... */
}

export const createServiceAction = withAuth(
  async (input: ActionInput, user): Promise<ActionOutput> => {
    // 1. (M8) 资产前置检查
    const resume = await db.resume.findFirst({
      where: { userId: user.id, status: 'COMPLETED' },
    })
    if (!resume) return { success: false, error: 'ResumeNotReady' }
    const detailedResume = await db.detailedResume.findFirst({
      where: { userId: user.id, status: 'COMPLETED' },
    })

    const { formData, locale } = input
    const jdText = formData.get('jd_text') as string | null
    const jdImage = formData.get('jd_image') as File | null
    const isImageUpload = !!(jdImage && jdImage.size > 0)

    // 2. (M2) 金币与路由
    const cost = isImageUpload ? 3 : 2 // M9 任务链 成本
    const hasQuota = await quotaDAL.checkBalance(user.id, cost)
    const { isFree } = !hasQuota

    // 3. (M6) 背压
    // (AI IDE: 必须实现 M6.2 规范，检查所有将被调用的队列)

    // 4. (M2) 扣费
    // (AI IDE: 实现 M2.2 规范，如果 hasQuota，则 deductQuota)

    // 5. (M1) 创建服务单元 (级联创建)
    const service = await db.service.create({
      data: {
        userId: user.id,
        resumeId: resume.id,
        detailedResumeId: detailedResume?.id,
        currentStep: 'MATCH',
        job: { create: { status: isImageUpload ? 'PENDING' : 'IDLE' } }, // PENDING 用于 OCR
        match: { create: { status: 'PENDING' } },
        // (M10 预创建)
        customizedResume: { create: { status: 'IDLE' } },
        interview: { create: { status: 'IDLE' } },
      },
      include: { job: true, match: true },
    })
    const jobId = service.job!.id
    const matchId = service.match!.id

    // 6. (M7) 埋点
    trackEvent(user.id, 'TASK_CREATED', {
      task: 'job_match',
      isFree,
      inputType: isImageUpload ? 'image' : 'text',
    })

    // 7. (M6) QStash 任务链
    if (isImageUpload) {
      // --- 复杂任务链 (OCR) ---
      const visionRouting = getJobVisionTaskRouting(hasQuota)
      const summaryRouting = getTaskRouting('job_summary', hasQuota)
      const matchRouting = getTaskRouting('job_match', hasQuota)

      // (AI IDE: 此处需处理图片上传到 R2/S3，获取 URL)
      const imageUrl = '...'

      // (M6.3) 推送 Task A (OCR)
      const { messageId: ocrTaskId } = await pushTaskToQueue(
        visionRouting.queueId,
        'ocr-processor',
        {
          taskTemplateId: 'job_ocr_task_id_placeholder', // (M4 需补充 OCR Prompt)
          modelId: visionRouting.modelId,
          locale,
          context: {
            userId,
            serviceId: service.id,
            taskId: jobId,
            imageUrl,
            queueId: visionRouting.queueId,
          },
        }
      )

      // (M6.3) 推送 Task B (Summary), 依赖 A
      const { messageId: summaryTaskId } = await pushTaskToQueue(
        summaryRouting.queueId,
        'batch-processor',
        {
          taskTemplateId: 'job_summary',
          modelId: summaryRouting.modelId,
          locale,
          context: {
            userId,
            serviceId: service.id,
            taskId: jobId,
            queueId: summaryRouting.queueId,
          },
        },
        { dependsOn: ocrTaskId }
      )

      // (M6.3) 推送 Task C (Match), 依赖 B
      await pushTaskToQueue(
        matchRouting.queueId,
        'stream-processor',
        {
          taskTemplateId: 'job_match',
          modelId: matchRouting.modelId,
          locale,
          context: {
            userId,
            serviceId: service.id,
            taskId: matchId,
            queueId: matchRouting.queueId,
          },
        },
        { dependsOn: summaryTaskId }
      )

      revalidatePath(`/${locale}/workbench`)
      return {
        success: true,
        serviceId: service.id,
        status: 'OCR_PENDING',
        isFree,
      }
    } else {
      // --- 文本任务链 ---
      // (M6.3) 推送 Task B (Summary)
      const summaryRouting = getTaskRouting('job_summary', hasQuota)
      const { messageId: summaryTaskId } = await pushTaskToQueue(
        summaryRouting.queueId,
        'batch-processor',
        {
          taskTemplateId: 'job_summary',
          modelId: summaryRouting.modelId,
          locale,
          context: {
            userId,
            serviceId: service.id,
            taskId: jobId,
            rawText: jdText,
            queueId: summaryRouting.queueId,
          },
        }
      )

      // (M6.3) 推送 Task C (Match), 依赖 B
      const matchRouting = getTaskRouting('job_match', hasQuota)
      await pushTaskToQueue(
        matchRouting.queueId,
        'stream-processor',
        {
          taskTemplateId: 'job_match',
          modelId: matchRouting.modelId,
          locale,
          context: {
            userId,
            serviceId: service.id,
            taskId: matchId,
            queueId: matchRouting.queueId,
          },
        },
        { dependsOn: summaryTaskId }
      )

      revalidatePath(`/${locale}/workbench`)
      return {
        success: true,
        serviceId: service.id,
        status: 'SUMMARY_PENDING',
        isFree,
      }
    }
  }
)
```

---

#### 任务 5：(AI IDE) `[serviceId]` 历史/状态机页面 (M9+M10)

- **目标**：实现 M9/M10 的“五态” UI 和“历史查看”功能。
- **文件 5.1**：`app/[locale]/workbench/[serviceId]/page.tsx`
- **AI IDE 动作**：创建动态路由页面 (Server Component)。

<!-- end list -->

```typescript
// AI IDE: Create this file at app/[locale]/workbench/[serviceId]/page.tsx
import { auth } from '@job-assistant/authkit'
import { db } from '@/lib/prisma'
import { notFound, redirect } from 'next/navigation'
import { Locale } from '@/i18n-config'
import { getDictionary } from '@/lib/i18n/dictionaries'
import { ServiceDisplay } from '@/components/app/ServiceDisplay' // M9.5.2

export default async function ServicePage({
  params: { locale, serviceId },
}: {
  params: { locale: Locale; serviceId: string }
}) {
  // 1. (M2) 认证
  const session = await auth()
  if (!session?.userId) redirect(`/${locale}`)

  // 2. (M1) 获取完整服务数据 (Rule 8.4)
  const service = await db.service.findFirst({
    where: {
      id: serviceId,
      userId: session.userId,
    },
    include: {
      job: true,
      match: true,
      customizedResume: true,
      interview: true,
    },
  })

  if (!service) notFound()

  const dict = (await getDictionary(locale)).workbench

  // 3. 传递给客户端组件
  return <ServiceDisplay initialService={service} locale={locale} dict={dict} />
}
```

- **文件 5.2**：`lib/hooks/useSseStream.ts` (M9.6)
  - **AI IDE 动作**：**创建** M6 指南 中定义的 `useSseStream` Hook。
- **文件 5.3**：`components/app/ServiceDisplay.tsx` (M9/M10 核心 UI)
- **AI IDE 动作**：创建客户端“状态机”组件。

<!-- end list -->

```typescript
// AI IDE: Create this file at components/app/ServiceDisplay.tsx
'use client'
import { useWorkbenchStore } from '@/lib/stores/workbench.store' // M9.2
import { useTaskPolling } from '@/lib/hooks/useTaskPolling' // M8
import { useSseStream } from '@/lib/hooks/useSseStream' // M9.6
import /* (M10 Actions) */ '@/lib/actions/service.actions'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs' //
// (Import M3 components: AppCard, Progress, Alert, Button, etc.)
// (Import M10 component: MarkdownEditor)

// (AI IDE: 必须实现一个完整的 React 组件，它...)
// 1. 接收 `initialService` prop。
// 2. 使用 `useWorkbenchStore` 管理状态。
// 3. **(M9.5) 轮询/流式混合握手**：
//    - `useEffect` 检查 `initialService.match.status`。
//    - if 'PENDING' (Task B)：启动 `useTaskPolling`。
//    - if 'MATCH_PENDING' (Task C)：启动 `useSseStream`。
// 4. **渲染 "五态" UI**：
//    - `Tab 1 (Match)`：根据 `status`（'OCR_PENDING', 'SUMMARY_PENDING', 'MATCH_STREAMING', 'COMPLETED'） 渲染不同的 `Progress`、提示文本 或流式 `streamingResponse`。
//    - `Tab 2 (Customize)`：
//        - `if (status === 'COMPLETED')` 渲染 M10.2 的 `<MarkdownEditor />`。
//        - `if (status === 'IDLE')` 渲染 `Button("生成定制化简历")`。
//        - `onClick` 必须调用 `customizeResumeAction` 并启动 `useTaskPolling`。
//    - `Tab 3 (Interview)`：
//        - `if (status === 'COMPLETED')` 渲染结果。
//        - `if (status === 'IDLE')` 渲染 `Button("生成面试 Tips")`。
//        - `onClick` 必须调用 `generateInterviewTipsAction` 并启动 `useSseStream`。
```

---

#### 任务 6：(AI IDE) Markdown 编辑器 (M10.2)

- **目标**：实现“编辑、同步滚动、导出 PDF”功能。
- **文件**：`components/app/MarkdownEditor.tsx` (新建)
- **动作 (AI IDE)**：
  1.  **安装依赖**：`pnpm add @uiw/react-markdown-editor jspdf html2canvas @react-pdf/renderer`。
  2.  **`MarkdownEditor` 组件**：
      - 使用 `@uiw/react-markdown-editor` 实现左右分栏（`MarkdownEditor`）。
      - 确保 `enableScrollSync={true}`。
      - **(UX 关键)** 预览窗格 (`preview`) **必须**使用 M3 的排版规范（`prose`）进行渲染，使其“看起来专业”。
  3.  **`ExportPDFButton` 组件**：
      - 创建一个新组件，`onClick` 时：
      - (方案 A: `jspdf + html2canvas`)：获取预览 `div` 的 DOM，使用 `html2canvas` 转为图片，再用 `jspdf` 存为 PDF。
      - (方案 B: `@react-pdf/renderer`)：(更优，但更复杂) 在**客户端**定义 PDF 文档结构，将 Markdown 转换为 PDF 元素并渲染。
      - **(M10 决策)**：AI IDE 优先实现方案 A (`html2canvas`)，满足 MVP 快速导出。

---

#### 任务 7：(AI IDE) `Profile Page` Billing (M10.3)

- **目标**：实现“金币历史”和“等待列表”。
- **文件 7.1**：`app/[locale]/profile/page.tsx` (升级)
- **AI IDE 动作**：
  1.  在 `ProfilePage` (Server Component) 的 `load` 函数中，**新增** `db.llmUsageLog.findMany` 和 `db.paymentWaitlist.findFirst` 的数据获取。
  2.  将 `llmUsageLogs` 和 `isOnWaitlist` 作为 `props` 传递给客户端组件 `<BillingTab />`。
- **文件 7.2**：`lib/actions/payment.actions.ts` (新建)
- **AI IDE 动作**：创建 `joinPaymentWaitlistAction`。

  ```typescript
  // AI IDE: Create this file at lib/actions/payment.actions.ts
  'use server'
  import { z } from 'zod'
  import { withAuth } from '@/lib/auth/wrapper'
  import { db } from '@/lib/prisma'
  import { trackEvent } from '@/lib/analytics' // M7

  export const joinPaymentWaitlistAction = withAuth(
    async (input: { email: string }, user) => {
      try {
        await db.paymentWaitlist.upsert({
          where: { userId: user.id },
          create: { userId: user.id, email: input.email },
          update: { email: input.email },
        })
        trackEvent(user.id, 'WAITLIST_JOINED', { email: input.email }) // M7 埋点
        return { success: true }
      } catch (error) {
        return { success: false, error: (error as Error).message }
      }
    }
  )
  ```

- **文件 7.3**：`components/app/BillingTab.tsx` (新建)
- **AI IDE 动作**：创建 M10 的 `Billing` 选项卡 UI。
  - (AI IDE: 必须包含：
  <!-- end list -->
  1.  `AppCard` 显示当前 Quota `balance`。
  2.  `PaymentWaitlistForm` (Client Component)，调用 `joinPaymentWaitlistAction`，并处理 `isPending` 和 `success` 状态。
  3.  `QuotaHistoryTable` (Client Component)，使用 `Table` (shadcn/ui) 展示 `llmUsageLogs` 属性。)

---

#### 任务 8：(AI IDE) M10 Analytics 注入 (M10.5)

- **目标**：将 M7 的 `trackEvent` 注入 M10 的新流程中。
- **AI IDE 动作**：
  1.  在 `customizeResumeAction` 和 `generateInterviewTipsAction` 中，**必须**调用 `trackEvent(..., 'TASK_CREATED', ...)`。
  2.  在 `batch-processor` 和 `stream-processor` 的 `try/catch` 块中，**必须**为 `customize` 和 `interview_prep` 添加 `TASK_COMPLETED` 和 `TASK_FAILED` 事件。
