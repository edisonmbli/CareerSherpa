# 文档 2：解决方案文档 (Solution Design Document)

这份文档的目的是定义“How”——我们如何从技术上实现【Project Spec】中定义的需求。

**致 AI IDE / 开发伙伴**：
这是颠覆性重构的技术蓝图。我们将在这里**抛弃**原型的核心缺陷（本地队列和阻塞流程），并**构建**一个全新的、生产级的异步架构。

- **原型遗产（保留）**：

  - 技术栈（Next.js, Vercel, Neon, Prisma, Neon Auth）。
  - 认证包装器（`lib/api/auth-wrapper.ts`）和 DAL 的基本概念（`lib/dal.ts`）
  - 基本需求（Match, Customize, Interview 三步曲）。

- **原型包袱（彻底废弃）**：
  - **`lib/llm/llm-scheduler.ts`**：原型的本地内存队列。它与 Vercel 架构**根本不兼容**，必须**彻底删除**。
  - **同步阻塞流程**：原型中“创建服务”时（`createServiceAction`） 一次性、同步执行所有 Summary 的流程**必须废弃**。
  - **混乱的队列设计**：原型中 `type + tier` 的队列设计过于复杂且不贴合业务，**必须废弃**。
  - **数据库结构**：原型的 `prisma.schema` 无法支撑新流程，我们将**重置数据库** (`prisma migrate reset`)。

---

## 主题 2.1：关键概念和架构设计

### 2.1.1 核心架构思想：Vercel 优先的异步架构

**旧架构（原型）**：
`[用户] -> [Server Action (阻塞)] -> [本地内存队列 (llm-scheduler.ts)] -> [LLM (同步等待)] -> [返回 Response]`

- **缺陷**：Vercel Serverless 函数有超时限制（例如 10-60s），而 LLM 任务（尤其是 `detailed_resume`）可能耗时数分钟，导致请求**必定超时**。且内存队列在 Serverless 环境下会丢失状态。

**新架构（重构）**：
`[用户] -> [Server Action (立即返回)] -> [Upstash QStash (消息队列)] -> [API Route (Worker)] -> [Upstash Redis (并发锁)] -> [LLM] -> [DB (写结果)]`

- **优势**：
  1.  **Vercel 兼容**：Server Action 立即响应（例如返回 `taskId`），用户界面不卡顿（满足 NFR-1.2）。
  2.  **异步长任务**：`Upstash QStash` 作为专用的消息代理，负责调用 Vercel 上的 Worker (API Route)，完美解决长时任务（FR-3.2）。
  3.  **分布式并发控制**：使用 `Upstash Redis` 作为分布式锁，精确控制 LLM API 的并发量（NFR-2.4），防止上游封禁。

### 2.1.2 关键概念 1：“资产”与“服务”的分离（流程重构）

这是本次重构最重要的**产品流程变更**，AI IDE 必须在所有 Server Actions 和页面设计中严格遵守此分离模型。

**1. 求职资产 (Assets) - （低频管理）**

- **定义**：用户的基础材料。
- **包含**：`个人通用简历` (1 份) 和 `个人详细履历` (1 份)。
- **管理页面**：`Profile Page`。
- **处理流程**：
  1.  用户在 `Profile Page` 上传 PDF。
  2.  Server Action 触发**原子化扣金币**（-1）。
  3.  将 `Task-resume` 或 `Task-detailed_resume` **推入 QStash 队列**。
  4.  Action **立即返回**，前端提示“正在后台解析中...”。
  5.  QStash Worker 异步执行 LLM 任务，将 `resume_summary_json` 写回数据库。

**2. 求职服务 (Services) - （高频使用）**

- **定义**：用户针对**特定 JD（岗位）**发起的一次 AI 定制化请求。
- **包含**：一个 `service_id`，关联 `job_id` 以及后续产出的 `match_id`, `customize_id`, `interview_id`。
- **管理页面**：`Workbench Page`。
- **处理流程**：
  1.  用户在 `Workbench` 粘贴 JD（或截图）。
  2.  Server Action **检查“资产”是否就绪**（`resume_summary_json` 是否存在？）（FR-2.2）。
  3.  触发**原子化扣金币**（-2）。
  4.  **同步**执行 `Task-job`（如果是纯文本，速度快），**异步**（QStash）执行 `Task-match`（RAG + LLM，耗时长）。
  5.  Action **立即返回**，前端通过 **SSE 流式 (FR-3.7)** 接收 `Task-match` 的结果。

**对 AI IDE 的指令**：

- **废弃**：原型中 `createServiceAction` 里所有关于 `resume` 的逻辑。
- **新建**：`Profile Page` 专用的 `uploadResumeAction` 和 `uploadDetailedResumeAction`。
- **重构**：`createServiceAction`（在 `Workbench` 中）必须**假定**简历资产已解析完毕，它只负责 `job` 的解析和 `match` 任务的调度。

### 2.1.3 关键概念 2：“金币” (Quotas) 与“队列” (Queues)

这是重构后商业化 (FR-5) 和 LLM 调度 (FR-3) 的核心。

**1. 金币 (Quotas) 逻辑**

- **定义**：“金币”是 LLM 任务的调用凭证。
- **原子化**：所有扣费/返还必须是数据库**事务**（NFR-3.1）。
- **扣费点 (Deduction)**：在任务**推入 QStash 之前**（Server Action 中）完成扣费。
- **返还点 (Reversal)**：在 QStash Worker **确认任务最终失败**后（例如 LLM API 500 或 RAG 失败）触发返还。
- **计费表**：（参照 `项目颠覆性重构的想法.md`）
  - `上传通用简历`: -1 金币
  - `上传详细履历`: -1 金币
  - `创建求职服务` (含 Job + Match): -2 金币
  - `帮我改简历` (Customize): -2 金币
  - `生成面试Tips` (Interview): -2 金币

**2. 队列 (Queue) 逻辑（新版 LLM 调度器）**

- **定义**：队列** 按任务的“体验模式”+用户的“付费等级”划分**。
- **队列选择**：所有 Server Action 在推送 QStash 任务时，必须先检查用户 `quotas` 余额：
  - `quotas > 0`：推送到**付费队列** (e.g., `q_paid_stream`)。
  - `quotas <= 0`：推送到**免费队列** (e.g., `q_free_stream`)。
- **队列模型**：使用 UpStash Qstash 控制，共设置 6 个队列

  - export enum QueueId {
    PAID_STREAM = 'q_paid_stream',
    PAID_BATCH = 'q_paid_batch',
    PAID_VISION = 'q_paid_vision',

    FREE_STREAM = 'q_free_stream',
    FREE_BATCH = 'q_free_batch',
    FREE_VISION = 'q_free_vision',
    }

- **LLM 模型并发**：使用 UpStash Redis 控制。这里最 tricky 的是 `glm-4.1v-thinking-flash`，它有两个用户状态：付费和免费。
  | 模型 | 用户状态 | 并发锁 (Qstash Redis) |
  | :--- | :--- | :--- |
  | `deepseek-reasoner` | 付费 | 5 |
  | `deepseek-chat` | 付费 | 5 |
  | `glm-4.5-flash` | 免费 | 2 |
  | `glm-4.1v-thinking-flash` | 付费 | 3 |
  | `glm-4.1v-thinking-flash` | 免费 | 2 |

- **任务路由**：Server Action 需根据**任务类型**和**用户状态**，将任务推送到**正确的 QStash 队列**。例如：
  | 任务 | 用户状态 | QStash 队列名 | 模型 |
  | :--- | :--- | :--- | :--- |
  | `resume_summary` | 付费 | q_paid_batch | `deepseek-chat` |
  | `resume_summary` | 免费 | q_free_batch | `glm-4.5-flash` |
  | `detailed_resume_summary` | 付费 | q_paid_batch | `deepseek-reasoner` |
  | `detailed_resume_summary` | 免费 | q_free_batch | `glm-4.5-flash` |
  | `job_summary` | 付费 | q_paid_batch | `deepseek-chat` |
  | `job_summary` | 免费 | q_free_batch | `glm-4.5-flash` |
  | `job_match` | 付费 | q_paid_stream | `deepseek-reasoner` |
  | `job_match` | 免费 | q_free_stream | `glm-4.5-flash` |
  | `resume_customize` | 付费 | q_paid_batch | `deepseek-chat` |
  | `resume_customize` | 免费 | q_free_batch | `glm-4.5-flash` |
  | `interview_prep` | 付费 | q_paid_stream | `deepseek-chat` |
  | `interview_prep` | 免费 | q_free_stream | `glm-4.5-flash` |
  | `OCR` | 付费 | q_paid_vision | `glm-4.1v-thinking-flash` |
  | `OCR` | 免费 | q_free_vision | `glm-4.1v-thinking-flash` |

### 2.1.4 高层数据流（示例：新用户完整流程）

**1. [注册与首次使用]**

- `[User]` -> `[Neon Auth]` 完成注册。
- Neon Auth 自动将新用户记录同步到 `neon_auth.users_sync` 表。
- `[User]` -> `[Profile Page]` 上传 `resume.pdf`（这是他的**第一次**业务操作）。

**2. [资产上传与金币初始化（Lazy Init）]**

- `[Server Action: uploadResume]` 触发：
  - **(新逻辑)** `DAL.quotas.find(userId)`：检查 `quotas` 表。
  - **发现 `quotas` 为空**（首次操作）。
  - **DB 事务 (初始化)**：`DAL.quotas.create(userId, 8)` -> **原子化**创建记录并赠送 8 金币。
  - **(原逻辑继续)** 检查 `quotas` (8 > 0) -> 判定为“付费队列”。
  - **DB 事务 (扣费)**：`quotas` 减 1 (剩余 7)。
  - **QStash 推送**：将 `Task-resume` 推送到 `q_deepseek_chat` 队列。
  - **立即返回** HTTP 200。

**3. [QStash Worker - 资产]**

- `[QStash Worker: q_deepseek_chat]` (API Route) 被调用，处理简历，并将 `resume_summary_json` 写回 `resumes` 表。

**4. [使用服务 - (含图片上传处理)]**

- `[User]` -> `[Workbench Page]` **上传 JD 截图** (e.g., `job.png`)。
- `[Server Action: createService]` 触发：
  - 检查 `quotas` (7 > 0) -> 判定为“付费队列”。
  - **DB 事务 (扣费)**：`quotas` 减 2 (剩余 5)。
  - 创建 `services` 记录 (生成 `service_id`)。
  - **(更新逻辑)** **检测到输入为图片**：
    - **QStash 推送 (Job)**：将 `Task-job (截图)` 推送到 `q_glm_vision_paid` 队列（这是一个**异步**前置任务）。
    - **QStash 推送 (Match)**：将 `Task-match` 推送到 `q_deepseek_reasoner` 队列，并设置**依赖 (dependency)**，使其在 `Task-job` **成功后**才执行。
  - **立即返回** HTTP 200，前端显示“正在解析岗位截图...” (`progress display`)。

**5. [使用服务 - (纯文本处理)]**

- `[User]` -> `[Workbench Page]` **粘贴 JD 文本**。
- `[Server Action: createService]` 触发：
  - 检查 `quotas` (5 > 0) -> 判定为“付费队列”。
  - **DB 事务 (扣费)**：`quotas` 减 2 (剩余 3)。
  - 创建 `services` 记录 (生成 `service_id`)。
  - **(更新逻辑)** **检测到输入为文本**：
    - **同步**调用 LLM (`q_deepseek_chat`) 解析 `job` 文本（因为快，< 3s）。
    - `job_summary_json` **立即**落表。
    - **QStash 推送 (Match)**：将 `Task-match` 推送到 `q_deepseek_reasoner` 队列。
  - **立即返回** HTTP 200，并带上 **SSE 连接**，准备流式接收 `Task-match` 的结果。

**6. [任务失败示例]**

- `[QStash Worker: q_deepseek_reasoner]` 失败。
- Worker 触发返还逻辑：**DB 事务**将 `quotas` 加 2 (剩余 5)。
- 通过 SSE 或前端轮询，通知用户任务失败及金币已返还。

---

## 主题 2.2：基础建设 (Infrastructure)

**致 AI IDE / 开发伙伴**：
本节是重构的“地基”。我们将详细定义如何**新建**或**重构**四个核心组件。

1.  **Neon Auth**：从“已集成”升级到“与业务（金币）深度绑定”。
2.  **RAG**：从“已启用 `pgvector`” 升级到“可实现调用的知识库”。
3.  **LLM 调度器**：**彻底废弃**原型的本地队列 (`llm-scheduler.ts`)，**新建**一个基于 `QStash + Vercel KV` 的生产级异步队列。
4.  **商业化（金币）**：**新建**一个原子化的 `quotas`（金币）管理系统，支撑所有 LLM 任务的计费与返还。

---

### 2.2.1 Neon Auth 认证集成

**1. 目标**
在原型（Prototype）已集成的基础上，将其与我们的核心业务（`quotas` 金币系统）进行绑定，并为 `Profile Page` 提供数据支持。

**2. 方案设计**

- **保留（原型遗产）**：我们将继续使用 Neon Auth 自动同步的 `neon_auth.users_sync` 表。应用中所有的业务表（如 `services`, `resumes`）都必须使用 `users_sync` 表的 `id`（即 `user_id`）作为外键。
- **重构（抛弃 DB Trigger）**：
  - **问题**：如 2.1.4 所述，我们不确定新用户在 `users_sync` 表中创建后，何时能安全地为其创建 `quotas` 记录。
  - **方案**：**不使用 DB Trigger**。我们将采用**“延迟初始化 (Lazy Initialization)”**策略。
- **新建（“延迟初始化”逻辑）**：
  - 我们将创建一个 `DAL`（数据访问层）函数，例如 `getOrCreateQuotas(userId: string)`。
  - 任何需要用户金币（Quotas）的 Server Action（例如 `uploadResumeAction` 或 `createServiceAction`）在执行业务逻辑**之前**，**必须**调用此函数。
  - 此函数会尝试查询 `quotas` 表。如果找不到该 `userId` 的记录（说明这是用户的首次操作），它将在一个**原子事务**中创建一条新记录，并填入初始赠送的金币数（例如 8 枚）。
- **新建（Profile 管理）**：
  - 为 `Profile Page` (`/profile`) 建立对应的 Server Action。
  - 这些 Action 将负责处理“资产管理”（`uploadResumeAction`, `uploadDetailedResumeAction`）和“商业化”（`createStripeCheckoutSessionAction`）的请求。

---

### 2.2.2 RAG (Retrieval-Augmented Generation)

**1. 目标**
启用 `pgvector` 只是第一步。我们需要一个完整的流程，将你提供的“求职宝典”文档加工成可检索的知识库，并在 LLM 调用时（`match`, `customize`, `interview`）注入相关上下文。

**2. 方案设计**
我们将 RAG 流程分为“离线入库”和“在线检索”：

- **离线入库 (Ingestion)**：
  1.  **AI IDE 任务**：创建一个脚本 (例如 `scripts/ingest-rag-docs.ts`)。
  2.  **数据源**：该脚本将读取你提供的“求职面试干货”文档（例如 Markdown, PDF）。
  3.  **分块 (Chunking)**：使用 `LlamaIndex` 的文本分割器，将文档切分为有意义的小块 (Chunks)。
  4.  **嵌入 (Embedding)**：调用嵌入模型（智谱的 `GLM embedding-3`） 将每个 Chunk 转换为向量 (Vector)。
  5.  **入库 (Storage)**：将 Chunk 文本、元数据 (metadata) 和向量存入 `rag_doc_chunks` 数据表（基于下文的表设计部分，参考 prisma.schema）。
- **在线检索 (Retrieval)**：
  1.  **AI IDE 任务**：创建一个可复用的 RAG 检索模块 (例如 `lib/rag/retriever.ts`)。
  2.  **输入**：一个查询字符串（例如 `match` 任务的岗位匹配度分析）。
  3.  **检索**：该模块负责将查询字符串*嵌入*为向量，然后使用 `pgvector` 的 `cosine` 距离查询 `rag_doc_chunks` 表，返回 Top-K（例如 K=3）最相关的文本块。
  4.  **输出**：返回 K 个相关文本块的字符串。
- **流程集成**：
  - 在（2.2.3 中定义的）LLM Worker 中，当处理 `match`, `customize` 或 `interview` 任务时，Worker 必须：
    1.  先调用“在线检索”模块，获取 RAG 上下文。
    2.  将 RAG 上下文**注入**到该任务的 Prompt 模板中。
    3.  最后才调用 LLM。

---

### 2.2.3 LLM 调度器 (Refactored)

**1. 目标**
**（重构核心）** 彻底废弃原型的本地内存队列 (`llm-scheduler.ts`)，新建一个基于 `Upstash QStash` 和 `Upstash Redis` 的、与 Vercel Serverless 架构 100% 兼容的异步 LLM 调度器。

**2. 方案设计**
新架构分为“生产者”和“消费者”：

- **生产者 (Server Actions)**：

  - **定义**：用户在前端触发的 Server Action (例如 `uploadResumeAction`, `createServiceAction`)。
  - **职责**：
    1.  **检查金币**：调用 `getOrCreateQuotas(userId)` 检查用户状态。
    2.  **选择队列**：根据 `quotas > 0` 和“任务类型”，决定目标 QStash 队列（例如 `q_deepseek_reasoner` 或 `q_glm_flash`）。
    3.  **原子化扣费**：调用 `DAL.quotas.deductQuota()`。
    4.  **推送任务**：将任务载荷（Payload）推送到选定的 QStash 队列。
    5.  **立即返回**：向前端立即返回 HTTP 200。

- **消费者 (API Route Workers)**：
  - **定义**：一系列专用的 API 路由 (例如 `/api/worker/deepseek-reasoner`)，它们是 QStash 任务的接收端。
  - **职责**：
    1.  **获取并发锁**：使用 `Upstash Redis` (Redis) 作为分布式锁（例如 `lock_ds_reasoner`），确保同时运行的 Worker 不超过并发上限（例如 5）。如果获取失败，QStash 会自动重试。
    2.  **执行任务**：调用 RAG（如果需要）、构建 Prompt、调用 LLM。
    3.  **处理结果**：将 `summary_json` 或其他结果写回 Prisma 数据库。
    4.  **处理失败**：如果任务（非瞬时）失败，**必须**调用 `DAL.quotas.addQuota()` 执行原子化金币返还。
    5.  **释放并发锁**：在 `Upstash Redis` 中释放该锁。

**3. 任务-队列映射表（AI IDE 必须遵守）**
| 任务 | 用户状态 | QStash 队列名 | 模型 | 并发锁 (Redis) |
| :--- | :--- | :--- | :--- | :--- |
| `resume_summary` | 付费 | q_paid_batch | deepseek-chat | 5 |
| `resume_summary` | 免费 | q_free_batch | glm-4.5-flash | 2 |
| `detailed_resume_summary` | 付费 | q_paid_batch | deepseek-reasoner | 5 |
| `detailed_resume_summary` | 免费 | q_free_batch | glm-4.5-flash | 2 |
| `job_summary` | 付费 | q_paid_batch | deepseek-chat | 5 |
| `job_summary` | 免费 | q_free_batch | glm-4.5-flash | 2 |
| `job_match` | 付费 | q_paid_stream | deepseek-reasoner | 5 |
| `job_match` | 免费 | q_free_stream | glm-4.5-flash | 2 |
| `resume_customize` | 付费 | q_paid_batch | deepseek-chat | 5 |
| `resume_customize` | 免费 | q_free_batch | glm-4.5-flash | 2 |
| `interview_prep` | 付费 | q_paid_stream | deepseek-chat | 5 |
| `interview_prep` | 免费 | q_free_stream | glm-4.5-flash | 2 |
| `OCR` | 付费 | q_paid_vision | glm-4.1v-thinking-flash | 3 |
| `OCR` | 免费 | q_free_vision | glm-4.1v-thinking-flash | 2 |

---

### 2.2.4 商业化策略 (Quota System)

**1. 目标**
**（新建核心）** 围绕“金币”(`quotas`) 构建一个健壮、可靠、原子的计费系统。这是确保商业模式（NFR-3.1）和免费/付费队列（FR-3.5）正常运转的基础。

**2. 方案设计**

- **数据表 (`quotas`)**：
  - **AI IDE 任务**：在 `prisma.schema` 中定义 `quotas` 表。
  - **字段**：`id` (PK), `userId` (FK, 1-to-1 to `neon_auth.users_sync`, Unique), `balance` (Int, 余额), `createdAt`, `updatedAt`。
  - **重置**：此为新表，随 `prisma migrate reset` 一起创建。
- **原子化 DAL (`lib/dal/quotas.ts`)**：
  - **AI IDE 任务**：创建一个专用的 DAL 模块，所有金币操作**必须**通过此模块。
  - **`getOrCreateQuota(userId)`**：实现 2.2.1 中定义的“延迟初始化”逻辑。
  - **`deductQuota(userId, amount)`**：**（核心）** 必须在 `prisma.$transaction` 中执行。它读取 `balance`，检查 `balance >= amount`，然后执行 `balance - amount` 的 `update`。如果检查失败，事务回滚并抛出“余额不足”错误。
  - **`addQuota(userId, amount, orderId)`**：必须在 `prisma.$transaction` 中执行 `balance + amount` 的 `update`。用于支付回调和失败返还。
- **任务成本配置**：（同原方案，AI IDE 需在 `lib/config.ts` 中定义成本表）。

- **MVP 支付意愿收集**
  - **前端**：`Profile Page` 的金币购买区，将替换为“功能即将上线”的占位符。
  - **交互**：提供一个 `Input`（预填用户邮箱）和一个 `Button`（“上线后通知我”）。
  - **后端**：创建一个新的 Server Action (`joinPaymentWaitlistAction`)，用于将 `userId` 和 `email` 写入新的 `PaymentWaitlist` 表。

---

### 2.2.6: Analytics 策略 (MVP)

- **描述**：为实现对核心业务指标的私有化跟踪，我们将创建一个 `AnalyticsEvent` 表。
- **AI IDE 任务**：必须创建一个 `lib/analytics.ts` 模块，包含一个核心函数：`trackEvent(userId, eventName, payload)`。
- **实现**：此函数**必须**是异步的（例如 `fire-and-forget`，不 `await`），以免阻塞 Server Action 的主流程。它唯一的职责就是向 `AnalyticsEvent` 表插入一条新纪录。
- **MVP 核心事件 (M8-M10 必须埋点)**：
  - `USER_SIGNED_UP`
  - `ASSET_UPLOADED` (payload: `{ type: 'resume' | 'detailed' }`)
  - `TASK_CREATED` (payload: `{ task: 'match' | 'customize' | 'interview', isFree: true | false }`)
  - `TASK_COMPLETED` (payload: `{ task: ... }`)
  - `TASK_FAILED` (payload: `{ task: ..., error: ... }`)
  - `WAITLIST_JOINED` (用于支付意愿)

---

## 主题 2.3：核心用户操作流 (Core User Flows)

### 2.3.0 关键设计决策

在进入流程分解前，我们先统一三个关键的设计决策：

#### 1. 金币不足与免费队列（处理反馈 1）

- **决策**：当用户金币不足以支付任务时，系统**不得驳回**请求。
- **方案**：
  1.  Server Action 在检查金币时，如发现余额不足，则**自动将任务降级**到“免费队列”（例如 `q_glm_flash`）。
  2.  Server Action 必须向前端返回一个 `isFree: true` 的标志。
  3.  前端（Client）在收到 `isFree: true` 标志后，**必须**立即显示一个非阻塞的提示（Toast）："金币不足，已为您转入免费队列。免费队列为低速、低配模型，如需享受更优质的服务，建议充值。"。

#### 2. 队列背压（处理反馈 2）

- **决策**：采用 Option 2 (限制队列长度)，防止队列无限积压。
- **方案**：
  1.  我们将使用 `UpStash Redis` 作为每个 QStash 队列的**原子计数器**。
  2.  **Server Action (生产者)**：在推送 QStash **之前**，`KV.incr(queue_counter_key)` 并检查返回值。如果 `count > MAX_QUEUE_LENGTH`（例如免费队列 20，付费队列 100），则**立即回滚** `KV.decr(queue_counter_key)`，并向前端返回错误："当前服务忙，请稍候再试"。
  3.  **QStash Worker (消费者)**：在任务（无论成功或失败）执行完毕的 `finally` 块中，**必须**执行 `KV.decr(queue_counter_key)`，释放队列名额。

#### 3. 异步状态更新（处理反馈 3）

- **决策**：在“轮询 (Polling)”和“WebSocket”之间，我们选择**轮询**。
- **原因**：
  - **架构适配**：Vercel (Serverless) 架构天生适合无状态的 HTTP 请求。而 WebSocket 是有状态的长连接，在 Vercel 上实现成本极高（通常需要第三方服务如 Ably/Pusher），增加了系统复杂度。
  - **体验平衡**：对于非即时流（如简历解析、简历定制），“智能轮询”（例如，前 15 秒每 2 秒一次，之后每 5 秒一次）配合后端的 `/api/task-status` 轻量级接口，是体验、成本和复杂度的最佳平衡点。
- **方案**：
  1.  所有**非 SSE 流式**的异步任务（如流程 1, 2, 4），Server Action 必须返回一个 `taskId`（例如 `resume.id`）。
  2.  前端在收到 `taskId` 后，开始轮询一个**新建的** API 路由：`GET /api/task-status?taskId=...&taskType=...`。
  3.  此 API 路由非常轻量，仅查询数据库中该任务的 `status` 字段 (`PENDING`, `COMPLETED`, `FAILED`) 并返回。
  4.  当前端轮询到 `COMPLETED` 或 `FAILED` 时，停止轮询，并触发数据刷新或显示错误。

---

### 流程 1：上传个人通用简历 (Asset Flow)

**需求引用**： 核心用户操作-1。

**1. 前端 (Client - `Profile Page`)**

- 用户上传 `resume.pdf`，触发 `uploadResumeAction`。
- 前端状态 `pending`，显示加载中。

**2. 后端 (Server Action - `uploadResumeAction`)**

- **认证**：获取 `userId`。
- **金币初始化**：`DAL.quotas.getOrCreateQuota(userId)`。
- **金币检查**：
  - `cost = config.costs.resume` (例如 1)。
  - `hasQuota = DAL.quotas.checkBalance(userId, cost)`。
  - `isFree = !hasQuota`。
- **队列选择**：`queueName = getQueueForTask('resume', hasQuota)`。
- **背压检查**（处理反馈 2）：
  - `counterKey = 'queue_counter_' + queueName`。
  - `count = KV.incr(counterKey)`。
  - `if (count > config.limits[queueName])`:
    - `KV.decr(counterKey)` (回滚)。
    - **返回错误**："当前服务忙，请稍候再试"。
- **金币扣减**：
  - `if (hasQuota)`: `DAL.quotas.deductQuota(userId, cost)`。
- **文件处理与落表**：`raw_text = ...`，`resume = DAL.resumes.upsert(...)`。
- **QStash 推送**：`QStash.push(queueName, { ..., resumeId: resume.id })`。
- **立即返回**：`{ success: true, isFree: isFree, taskId: resume.id, taskType: 'resume' }`。

**3. 后端 (QStash Worker - `api/worker/resume`)**

- `try { ... (获取锁、执行 LLM、写回结果) ... }`
- `catch (error) { ... (写回 FAILED 状态、返还金币) ... }`
- `finally { KV.decr(counterKey); ... (释放锁) ... }`（**必须**释放背压计数器）。

**4. 前端 (Feedback)**

- 前端收到 `success` 响应。
- `if (isFree)`: 显示降级提示 Toast。
- **启动轮询**（处理反馈 3）：`startPolling(taskId, taskType)`，轮询 `GET /api/task-status`。
- 轮询到 `COMPLETED`，提示“简历已解析完成”。

---

### 流程 2：上传个人详细履历 (Asset Flow)

**需求引用**： 核心用户操作-2。

- **实现**：此流程**完全复用**流程 1 的所有新逻辑（金币降级、背压、轮询）。
- **差异点**：`taskType: 'detailed_resume'`，`cost`，`queueName`，`DAL.detailed_resumes`。

---

### 流程 3：创建求职服务 (Service Flow - Step 1: Match)

**需求引用**： 核心用户操作-3。

**1. 前端 (Client - `Workbench Page`)**

- 用户粘贴 JD 文本或上传截图，触发 `createServiceAction`。

**2. 后端 (Server Action - `createServiceAction`)**

- **前置检查**：`resume = DAL.resumes.find(userId, { status: 'COMPLETED' })`（FR-2.2）。
- **金币检查**：`cost = config.costs.create_service`，`hasQuota = ...`，`isFree = !hasQuota`。
- **创建服务单元**：`service = DAL.services.create(...)`。
- **处理 Job（文本 vs 图片）**：
  - **Case A：上传 JD 截图 (`job_image`)**
    - `queue_job = getQueueForTask('job_image', hasQuota)`。
    - `queue_match = getQueueForTask('match', hasQuota)`。
    - **背压检查**：**必须**同时检查并 `incr` 两个队列 (`queue_job`, `queue_match`) 的计数器。任一队列忙碌，则**全部回滚**并返回错误。
    - `if (hasQuota)`: `DAL.quotas.deductQuota(userId, cost)`。
    - `QStash.push(queue_job, ...)`。
    - `QStash.push(queue_match, ..., { dependsOn: job_task_id })`。
    - **立即返回**：`{ service_id, isFree: isFree, stream: false, status: 'PENDING_OCR', taskId: service.id, taskType: 'service_match' }`。
  - **Case B：粘贴 JD 文本 (`job_text`)**
    - `queue_match = getQueueForTask('match', hasQuota)`。
    - **背压检查**：`KV.incr('queue_counter_' + queue_match)` 并检查。
    - `if (hasQuota)`: `DAL.quotas.deductQuota(userId, cost)`。
    - **同步**解析 `job` 文本，`job = DAL.jobs.create(...)`。
    - `QStash.push(queue_match, ...)`。
    - **立即返回**：`{ service_id, isFree: isFree, stream: true }` (SSE 模式)。

**3. 后端 (QStash Workers - `job` 和 `match`)**

- `finally` 块中**必须** `decr` 各自队列的 `queue_counter_key`。
- `match` Worker 通过 **SSE** (FR-3.7) 返回流式结果。

**4. 前端 (Feedback)**

- `if (isFree)`: 立即显示降级提示 Toast。
- **Case A (图片)**：收到 `{ stream: false }`。显示 `progress display` "正在解析岗位截图..."。**启动轮询** `startPolling(taskId, taskType)`。当轮询到状态变为 `STREAMING` (由 `match` worker 在开始时更新) 或 `COMPLETED` 时，切换到 SSE 连接或展示结果。
- **Case B (文本)**：收到 `{ stream: true }`。立即连接 SSE 端点，实时流式展示 `match` 结果。

---

### 流程 4：帮我改简历 (Service Flow - Step 2: Customize)

**需求引用**： 核心用户操作-4。

**1. 前端 (Client - `Workbench Page`)**

- 用户点击“帮我改简历”，触发 `customizeResumeAction`。

**2. 后端 (Server Action - `customizeResumeAction`)**

- **前置检查**：`match = DAL.matches.find(service_id)`。
- **金币检查**：`cost = config.costs.customize`，`hasQuota = ...`，`isFree = !hasQuota`。
- **队列选择**：`queueName = getQueueForTask('customize', hasQuota)`。
- **背压检查**：`KV.incr(...)` 并检查。
- **金币扣减**：`if (hasQuota)`: `DAL.quotas.deductQuota(...)`。
- **落表 (前置)**：`customResume = DAL.customized_resumes.create({ service_id, status: 'PENDING' })`。
- **QStash 推送**：`QStash.push(queueName, { ..., customResumeId: customResume.id })`。
- **立即返回**：`{ success: true, isFree: isFree, taskId: customResume.id, taskType: 'customize' }`。

**3. 后端 (QStash Worker - `api/worker/customize`)**

- `try { ... (获取锁、RAG、LLM、写回 Markdown 结果) ... }`
- `catch { ... (返还金币) ... }`
- `finally { KV.decr(counterKey); ... (释放锁) ... }`

**4. 前端 (Feedback)**

- `if (isFree)`: 显示降级提示 Toast。
- **启动轮询**（处理反馈 3）：`startPolling(taskId, taskType)`。
- 轮询到 `COMPLETED`，获取 `markdown_content` 并渲染到编辑器中 (FR-6.2)。

---

### 流程 5：生成面试 Tips (Service Flow - Step 3: Interview)

**需求引用**： 核心用户操作-5。

- **实现**：此流程是**流式 (SSE)** 的，因此它复用流程 3 (Case B) 的逻辑，而非流程 4。
- **前置检查**：`DAL.customized_resumes.find(service_id)` 必须 `COMPLETED`（FR-2.5）。
- **Server Action**：
  - 执行金币检查（`isFree`）、队列选择、**背压检查**（`KV.incr`）。
  - `if (hasQuota)` 则扣费。
  - 推送 QStash。
  - **立即返回**：`{ success: true, isFree: isFree, stream: true }`。
- **Worker**：
  - `try { ... (获取锁、RAG、LLM、通过 SSE 流式返回) ... }`
  - `finally { KV.decr(counterKey); ... (释放锁) ... }`
- **前端 (Feedback)**：
  - `if (isFree)`: 显示降 gid 提示。
  - 收到 `{ stream: true }`，立即连接 SSE 端点，实时展示面试 Tips (FR-3.7)。

---

## 主题 2.4：数据表设计 (Prisma Schema)

**致 AI IDE / 开发伙伴**：
这是一个全新的 `schema.prisma` 文件。它旨在**完全替换**旧的 `schema.prisma` 文件。请**备份旧文件**，然后使用以下内容覆盖。

执行 `prisma migrate reset`（或等效命令） 是启动新架构所必需的。

---

### 新的 `prisma.schema` 文件内容

```prisma
// ================================================================= //
//  1. Generator & Datasource (From Prototype, Must Keep)
// ================================================================= //

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["multiSchema"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  schemas  = ["neon_auth", "public"] // Required for Neon Auth
}

// ================================================================= //
//  2. Authentication (From Prototype, Must Keep)
// ================================================================= //
//  This table is managed by Neon Auth. We ONLY REFERENCE it.
//  DO NOT MODIFY.
// ================================================================= //

model users_sync {
  id                   String           @id @schema("neon_auth")
  raw_json             Json?            @schema("neon_auth")
  name                 String?          @schema("neon_auth")
  email                String?          @schema("neon_auth")
  created_at           DateTime?        @schema("neon_auth")
  deleted_at           DateTime?        @schema("neon_auth")
  updated_at           DateTime?        @schema("neon_auth")

  // --- NEW: Links to our business tables ---
  quota            Quota?
  resumes          Resume[]
  detailedResumes  DetailedResume[]
  services         Service[]
  paymentOrders    PaymentOrder[]

  @@map("users_sync")
  @@schema("neon_auth")
}

// ================================================================= //
//  3. NEW: Commercialization Models (Quotas & Payments)
//     (Replaces prototype 'Payment', adds 'Quota')
// ================================================================= //

// NEW: Tracks user's "coin" balance (Requirement 2.2.4)
model Quota {
  id        String     @id @default(cuid())
  // 1-to-1 link to the user
  userId    String     @unique @map("user_id")
  user      users_sync @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade, map: "quota_user_id_fkey")

  balance   Int        @default(0) // Coin balance

  createdAt DateTime   @default(now()) @map("created_at")
  updatedAt DateTime   @updatedAt @map("updated_at")

  @@map("quotas")
  @@schema("public")
}

// ================================================================= //
//  4. REFACTORED: Payment Model (PaymentWaitlist -> PaymentOrder)
//     (Replaces prototype 'PaymentWaitlist')
// ================================================================= //
model PaymentWaitlist {
  id        String     @id @default(cuid())
  userId    String     @unique @map("user_id") // 1-to-1 link
  user      users_sync @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  email     String     // The email to notify
  createdAt DateTime   @default(now()) @map("created_at")

  @@map("payment_waitlist")
  @@schema("public")
}
// REFACTORED: Renamed from prototype 'Payment' to track orders (Req 2.2.4)
//model PaymentOrder {
//  id              String        @id @default(cuid())
//  userId          String        @map("user_id")
//  // user            users_sync    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: Cascade, map: "payment_order_user_id_fkey")
//
//  amount          Int           // Amount in cents (e.g., 500 for 5 CNY)
//  quotaAmount     Int           // How many coins purchased (e.g., 10)
//  status          PaymentStatus @default(PENDING)
//
//  provider        String?       // e.g., "AggregatePay"
//  providerOrderId String?       @unique @map("provider_order_id") // The external order ID
//
//  createdAt       DateTime      @default(now()) @map("created_at")
//  updatedAt       DateTime      @updatedAt @map("updated_at")
//
//  @@index([userId, status])
//  @@map("payment_orders")
//  @@schema("public")
//}


// ================================================================= //
//  4. REFACTORED: User Asset Models (Resume & DetailedResume)
//     (Replaces prototype 'Resume' & 'DetailedResume')
// ================================================================= //

// REFACTORED: Cleaned up prototype 'Resume'
// This is Asset 1 (General Resume)
model Resume {
  id                String           @id @default(cuid())
  // 1-to-1 link to the user
  userId            String           @unique @map("user_id")
  user              users_sync       @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade, map: "resume_user_id_fkey")

  originalText      String?          @map("original_text")
  resumeSummaryJson Json?            @map("resume_summary_json")

  // NEW: Status for async polling (Requirement 2.3.0)
  status            AsyncTaskStatus  @default(PENDING)

  createdAt         DateTime         @default(now()) @map("created_at")
  updatedAt         DateTime         @updatedAt @map("updated_at")

  // Link to all services that USED this resume
  services          Service[]

  // DROPPED (from prototype): title, lang, active, tokens, mediaBase64, etc. (too complex)
  // DROPPED (from prototype): ResumeVersion model (not in MVP scope)

  @@map("resumes")
  @@schema("public")
}

// REFACTORED: Cleaned up prototype 'DetailedResume'
// This is Asset 2 (Detailed History)
model DetailedResume {
  id                  String           @id @default(cuid())
  // 1-to-1 link to the user
  userId              String           @unique @map("user_id")
  user                users_sync       @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade, map: "detailed_resume_user_id_fkey")

  originalText        String?          @map("original_text")
  detailedSummaryJson Json?            @map("detailed_summary_json") // Renamed from prototype

  // NEW: Status for async polling (Requirement 2.3.0)
  status              AsyncTaskStatus  @default(PENDING)

  createdAt           DateTime         @default(now()) @map("created_at")
  updatedAt           DateTime         @updatedAt @map("updated_at")

  // Link to all services that USED this detailed resume
  services            Service[]

  @@map("detailed_resumes")
  @@schema("public")
}


// ================================================================= //
//  5. REFACTORED: Core Service Flow Models
//     (Replaces prototype 'Service' and DROPS 'ServiceTask')
// ================================================================= //

// REFACTORED: The "Hub" model, simplified from prototype 'Service'
// Represents one "Job Customization" request (FR-2.4)
model Service {
  id               String          @id @default(cuid())
  userId           String          @map("user_id")
  user             users_sync      @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade, map: "service_user_id_fkey")

  // --- Links to the *exact* assets used for this Service ---
  resumeId         String          @map("resume_id")
  resume           Resume          @relation(fields: [resumeId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  detailedResumeId String?         @map("detailed_resume_id")
  detailedResume   DetailedResume? @relation(fields: [detailedResumeId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  // --- Step Tracking (Replaces prototype 'ServiceStatus' and 'ServiceDepth') ---
  currentStep      ServiceStep     @default(MATCH) @map("current_step")

  // --- NEW: Decoupled 1-to-1 links to service outputs ---
  job              Job?
  match            Match?
  customizedResume CustomizedResume?
  interview        Interview?

  createdAt        DateTime        @default(now()) @map("created_at")
  updatedAt        DateTime        @updatedAt @map("updated_at")

  // DROPPED (from prototype): resultJson (now decoupled), status (use currentStep)
  // DROPPED (from prototype): ServiceTask model (handled by QStash + KV)

  @@index([userId, createdAt(sort: Desc)]) // For history list (FR-2.7)
  @@map("services")
  @@schema("public")
}

// --- NEW: Decoupled Service Output Models ---

// NEW: Stores the Job (JD) extraction result
model Job {
  id             String           @id @default(cuid())
  // 1-to-1 link to the Service
  serviceId      String           @unique @map("service_id")
  service        Service          @relation(fields: [serviceId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  originalText   String?          @map("original_text")
  originalImage  String?          @map("original_image") // URL or Base64 of screenshot
  jobSummaryJson Json?            @map("job_summary_json")

  // NEW: Status for async OCR polling (Requirement 2.3.3)
  status         AsyncTaskStatus  @default(PENDING)

  createdAt      DateTime         @default(now()) @map("created_at")
  updatedAt      DateTime         @updatedAt @map("updated_at")
  @@map("jobs")
  @@schema("public")
}

// NEW: Stores the Step 1 (Match) result
model Match {
  id               String           @id @default(cuid())
  serviceId        String           @unique @map("service_id")
  service          Service          @relation(fields: [serviceId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  matchSummaryJson Json?            @map("match_summary_json") // Stores score, analysis, etc.
  status           AsyncTaskStatus  @default(PENDING) // PENDING (for SSE), COMPLETED, FAILED

  createdAt        DateTime         @default(now()) @map("created_at")
  updatedAt        DateTime         @updatedAt @map("updated_at")
  @@map("matches")
  @@schema("public")
}

// NEW: Stores the Step 2 (Customize) result
model CustomizedResume {
  id               String           @id @default(cuid())
  serviceId        String           @unique @map("service_id")
  service          Service          @relation(fields: [serviceId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  // The editable markdown (FR-6.2)
  markdownContent  String?          @map("markdown_content")
  status           AsyncTaskStatus  @default(PENDING) // For async polling (Requirement 2.3.4)

  createdAt        DateTime         @default(now()) @map("created_at")
  updatedAt        DateTime         @updatedAt @map("updated_at")
  @@map("customized_resumes")
  @@schema("public")
}

// NEW: Stores the Step 3 (Interview) result
model Interview {
  id                String           @id @default(cuid())
  serviceId         String           @unique @map("service_id")
  service           Service          @relation(fields: [serviceId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  interviewTipsJson Json?            @map("interview_tips_json") // Stores self-intro, tips list
  status            AsyncTaskStatus  @default(PENDING) // PENDING (for SSE), COMPLETED, FAILED

  createdAt         DateTime         @default(now()) @map("created_at")
  updatedAt         DateTime         @updatedAt @map("updated_at")
  @@map("interviews")
  @@schema("public")
}


// ================================================================= //
//  6. REFACTORED: RAG Model (Knowledge Base)
//     (Replaces prototype 'KnowledgeEntry')
// ================================================================= //

// REFACTORED: Simplified prototype 'KnowledgeEntry' for a global RAG store (Req 2.2.2)
model KnowledgeEntry {
  id        String                 @id @default(cuid())
  content   String                 // The text chunk

  // NOTE: Set vector dimensions to match your embedding model (e.g., 2048 for zhipu embedding-3)
  embedding Unsupported("vector(2048)")?

  lang     String                  // 'en' or 'zh'
  source    String?                // e.g., 'resume_writing_guide.pdf'
  category  String?                // 'match', 'customize', 'interview' (FR-4.3)
  isPublic  Boolean                @default(true) @map("is_public")

  createdAt DateTime               @default(now()) @map("created_at")
  updatedAt DateTime               @updatedAt @map("updated_at")

  // DROPPED (from prototype): userId, user relation, metadata.
  // REASON: RAG knowledge base is global (admin-managed), not per-user, for MVP.

  @@index([lang, category, isPublic])
  @@map("knowledge_entries")
  @@schema("public")
}

// DROPPED (from prototype): 'Document' model (merged into KnowledgeEntry)

// ================================================================= //
//  7. Refactored Enums
// ================================================================= //

// REFACTORED: Replaces prototype 'PaymentStatus'
//enum PaymentStatus {
//  PENDING
//  COMPLETED // Renamed from 'succeeded'
//  FAILED
//  REFUNDED
//  @@schema("public")
//}

// NEW: A reusable status for all async tasks (Req 2.3.0)
// Replaces prototype 'TaskStatus'
enum AsyncTaskStatus {
  PENDING   // Covers 'queued' and 'running' from prototype
  COMPLETED // Renamed from 'done'
  FAILED    // Renamed from 'error'
  @@schema("public")
}

// NEW: Tracks progress through the 3-step service (Req 2.1.2)
// Replaces prototype 'ServiceDepth'
enum ServiceStep {
  MATCH
  CUSTOMIZE
  INTERVIEW
  COMPLETED // All 3 steps are done
  @@schema("public")
}

// Tracks key user actions for internal analysis (100% data ownership)
model AnalyticsEvent {
  id        String     @id @default(cuid())

  // Can be null for anonymous events (like page_view on landing)
  userId    String?    @map("user_id")
  user      users_sync? @relation(fields: [userId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  eventName String     @map("event_name") // e.g., "TASK_CREATED"
  payload   Json?      // e.g., { "task": "match", "isFree": true }

  createdAt DateTime   @default(now()) @map("created_at")

  @@index([eventName, createdAt(sort: Desc)])
  @@index([userId, createdAt(sort: Desc)])
  @@map("analytics_events")
  @@schema("public")
}

// DROPPED (from prototype): ServiceStatus, TaskKind (no longer needed)
```

---

### 重构分析：为什么这样改？

**AI IDE 指南：**

1.  **用户模型 (`users_sync`)**：**保持不变**。这是 Neon Auth 的同步表，我们只通过 `userId` 关联它。
2.  **金币与支付 (`Quota`, `PaymentWaitlist`)**：
    - **新建 `Quota`**：这是 2.2.4 的核心，用于原子化计费。它必须与 `users_sync` 建立 `@@unique` 的 1-to-1 关系。
    - **新增 `PaymentWaitlist`**：用于存储“愿意购买服务”的用户邮箱，等支付环节打通后第一时间通知。
    - **重构 `PaymentOrder`**：基于原型的 `Payment`，但重命名以更清晰地反映“订单”概念，并添加了 `quotaAmount` 字段。[为后续支付功能上线预留]
3.  **资产模型 (`Resume`, `DetailedResume`)**：
    - **保留但简化**：我们保留了 `Resume` 和 `DetailedResume`，但**删除**了 `active`, `title`, `lang` 等所有 MVP 不需要的多余字段。
    - **1-to-1 关系**：通过 `@@unique([userId])` 强制实现每个用户只能有一份“通用简历”和一份“详细履历”。
    - **新建 `status` 字段**：这是**关键改动**。我们添加了 `AsyncTaskStatus` 字段，以支持 2.3.0 中定义的**前端轮询**（`Polling`）逻辑。
4.  **服务流程模型（核心解耦）**：
    - **`Service` (Hub)**：`Service` 表 被重构为“服务单元（Hub）”。它不再存储任何 `resultJson`。它只负责**关联** `User` 和他此次服务使用的 `Assets` (resumeId, detailedResumeId)，并用 `currentStep` 跟踪进度。
    - **新建 `Job`, `Match`, `CustomizedResume`, `Interview`**：这是**最大的架构变化**。我们将原型的 `resultJson` 和 `ServiceTask` 逻辑，**解耦**为四个独立的模型，每个模型都与 `Service` 1-to-1 关联。
    - **好处**：
      - **清晰**：数据结构与业务步骤（Match -\> Customize -\> Interview） 完全对应。
      - **可轮询**：每个新模型（`Job`, `CustomizedResume` 等）都有自己的 `status` 字段，允许前端**精确地轮询**特定任务的状态（例如 `GET /api/task-status?taskId=...&taskType=customize`）。
5.  **RAG 模型 (`KnowledgeEntry`)**：
    - **简化**：我们保留了原型的 `KnowledgeEntry`（用于 `pgvector`），但**删除了 `userId` 关联**。
    - **原因**：为了 MVP，RAG 知识库（2.2.2）是**全局的**（由管理员上传），而不是用户私有的。这大大降低了复杂度。
6.  **废弃的模型 (Dropped)**：
    - `ResumeVersion`：MVP 不支持源简历版本控制。
    - `ServiceTask`：异步任务的元数据现在由 `QStash` (外部) 和 `AsyncTaskStatus` (内部) 管理。
    - `AuditTrail`, `IdempotencyKey`：这些功能分别由 Vercel Logging (NFR-5) 和 Vercel KV (2.3.0) 在应用层处理，而不是在数据库中。

---

## 主题 2.5：页面设计 (Page Design & Flow)

### 2.5.1 视觉风格与标杆 (回答问题 3)

**1. 视觉标杆 (Benchmarks)**
我们不凭空设计。我们的标杆应该是业界顶级的“AI 工具”和“开发者工具”，它们完美符合“实用、专业、美观”的要求：

- **ChatGPT / Claude**：这是 AI 原生应用的标杆。它们确立了“左侧历史 + 中间对话”的黄金布局。
- **Vercel Dashboard**：这是 `shadcn/ui` 风格的最佳实践。它在信息密度、组件一致性和响应式设计上都是我们的榜样。

**2. 视觉策略 (How to achieve it)**

- **`shadcn/ui` 驱动**：我们**只**使用 `shadcn/ui` 组件。AI IDE 将直接使用 `Card`, `Tabs`, `Button`, `Toaster`, `Progress`, `Badge`, `AlertDialog` 等。这能确保视觉高度统一且专业。
- **留白与排版**：使用 `Tailwind` 的间距规范，确保足够的留白。使用干净的字体（如 `Geist` 或 `Inter`）。
- **反馈（Feedback）**：这是 AI 应用的灵魂。我们将大量使用：
  - **Toaster (轻提示)**：用于 2.3.0 中定义的“金币不足，转入免费队列”的提示。
  - **Progress (进度条)**：用于 2.3.0 中定义的“轮询”（Polling）任务，例如 `customize`（改简历）。
  - **流式（Streaming）**：直接在 `Card` 中渲染 SSE 流（FR-3.7），用于 `match` 和 `interview`。

---

### 2.5.2 页面流程与信息架构 (回答问题 2)

我们的页面流程**必须**严格遵循 2.1.2 中定义的“资产/服务分离”架构。

**页面信息架构 (Site Map):**

1.  `/` (Landing Page) —— (游客) 引导注册
2.  `/profile` (Profile Page) —— (用户) **管理“资产”** (低频)
3.  `/workbench` (Workbench Page) —— (用户) **使用“服务”** (高频)
4.  `/workbench/[serviceId]` —— (用户) **查看/续跑**历史服务

**核心流程 (Flow):**
`[游客]` -> `Landing Page` -> `[注册/登录]` -> `Profile Page` (引导上传资产) -> `Workbench Page` (开始使用服务)。

---

### 2.5.3 核心页面布局设计 (回答问题 1 & 4)

#### 页面 A：Landing Page (`/`)

- **用途 (Why)**：(FR-1.1) 核心价值主张，说服游客注册。
- **布局 (What - 桌面端)**：
  - **Hero (首屏)**： 简洁的标题（“AI 求职助手，三步拿到更高匹配度的面试机会”），副标题（匹配->定制->面试），以及一个醒目的 `Button (primary)`：“免费试用 (赠 8 金币)”。
  - **Value Props**：使用 `Card` 组件，并排 3 个，分别介绍“匹配度分析”、“简历定制化”、“面试要点清单”。
  - **How it works**：展示异步（QStash）、RAG、流式（SSE） 等技术特性，建立专业信任。
- **移动端适配 (How - 移动端)**：
  - 简单的单列垂直布局。`Card` 垂直堆叠。
- **SEO 要求**：
  - **1. 动态元数据 (Dynamic Metadata)**：
    _ `Landing Page` **必须**使用 Next.js 14+ 的 `generateMetadata` 函数。
    _ 页面的 `<title>` 和 `<meta name="description">` **严禁**硬编码在 `layout.tsx` 中。
    _ **必须**从 i18n 字典（`getDictionary(locale)`） 中动态获取 `title` 和 `description`，确保 `en` 和 `zh` 语言环境 的元数据不同。
    _ **必须**设置 `metadataBase` 和 `alternates` (hreflang)，以正确处理 i18n 架构 的 SEO。
  - **2. 结构化数据 (Structured Data - JSON-LD)**：
    - 为了实现 `SEO优化` 中“服务于 AI” 的目标，`Landing Page` **必须**注入 `JSON-LD` 结构化数据。
    - 可以使用 `SoftwareApplication` 或 `Service` schema，向 AI 引擎清晰地描述“AI 求职助手”是做什么的。

#### 页面 B：Profile Page (`/profile`)

- **用途 (Why)**：**“资产管理”**。这是用户**唯一**可以上传/管理 `Resume` 和 `DetailedResume` 的地方。同时承载**“金币管理”**。
- **布局 (What - 桌面端)**：
  - 使用 `Tabs` 组件将页面分为两部分：“求职资产”和“金币与账单”。
  - **Tab 1: 求职资产**
    - **`Card` 1 (通用简历 - 必选)**：
      - `Title`: "个人通用简历 (必选)"。
      - `Description`: "这是 AI 分析的基础，后续所有服务均依赖此文件。"
      - `Content`: 如果已上传，显示文件名和 `Badge (status)`（`PENDING` 或 `COMPLETED`）。
      - `Footer`: `Button (secondary)`：“替换文件”。（如果未上传，则显示文件上传框）。
    - **`Card` 2 (详细履历 - 可选)**：
      - `Title`: "个人详细履历 (强烈推荐)"。
      - `Description`: "提供更丰富的上下文，可显著提升 AI 输出质量（+20%）"。
      - (布局同 Card 1)。
  - **Tab 2: 金币与账单**
    - `Card`，内容为：
      - `Title`: "金币充值"
      - `Description`: "金币充值功能正在快马加鞭开发中。我们将在上线后第一时间通知您，感谢您的支持！"
      - `Content`: 一个包含 `Input` (预填用户邮箱) 和 `Button` ("上线后通知我") 的表单。
      <!-- - `Card 1 (当前余额)`： 大字显示金币 `balance`。
    - `Card 2 (购买金币)`：并排的 `Button` 选项（"10 金币 / 5 元", "50 金币 / 20 元"）。点击触发 2.3.0 中的 `createPaymentOrderAction`。
    - `Table (历史记录)`： 显示 `payment_orders` 表和金币消费记录（`quota_logs`）。 -->
- **移动端适配 (How - 移动端)**：
  - `Tabs` 保持在顶部。`Card` 组件垂直堆叠。`Table` 简化为 `List` 视图。

#### 页面 C：Workbench Page (`/workbench`)

- **用途 (Why)**：**“服务使用”**。这是用户 90% 的时间所在的地方，用于高频创建和查看 `service`。
- **布局 (What - 桌面端)**：
  - **采用“两列布局”**（Vercel / ChatGPT 标杆）。
  - **Column 1 (左侧导航栏 - `Sidebar`)**：
    - `Top`: Logo / `Button (primary)`: "+ 新建服务"（点击后重置中间列为“新建”状态）。
    - `Middle (scrollable)`: **历史服务列表 (FR-2.7)**。`List` 组件，每一项都是一个 `service_id`（显示 `job.title` 或 JD 摘要）。点击后将该 `service_id` 加载到中间列。
    - `Bottom`: `UserAvatar` (点击进入 `/profile`) / `Badge` ("金币: N") / `ThemeToggle` / `i18nToggle`。
    - **点击 i18nToggle 切换语言（如 en -> zh），仅切换当前页面的 locale 路径（例如从 /en/workbench 刷新到 /zh/workbench）**
  - **Column 2 (中间主工作区 - `Main Workspace`)**：
    - **这是动态内容区域，根据状态显示不同内容。**
    - **状态 1：新建服务 (Default)** (当用户点击 `+ 新建服务` 时)
      - `Label`: "粘贴岗位职责 (JD)"。
      - `Textarea`: 用于粘贴 JD 文本。
      - `Label` 或 `Button`: "或上传 JD 截图"（FR-2.3）。
      - `Button (primary)`: "开始分析 (Step 1)" (触发 `createServiceAction`)。
      - `Alert (Info)`: **前置检查提示 (FR-2.2)**。如果检测到 `resume.status !== 'COMPLETED'`，则禁用"开始分析"按钮，并显示提示："请先前往「个人主页」上传并等待通用简历解析完成"。
    - **状态 2：任务加载中 (Loading)**
      - **Case A (轮询)**: (例如 `customize`)。显示 `Progress` 进度条和 "正在生成定制化简历..."（2.3.0）。
      - **Case B (SSE 流式)**: (例如 `match` / `interview`)。显示一个 `Card`，AI 的 markdown 响应**实时流式**渲染在卡片内（FR-3.7）。
      - **Case C (背压)**: (例如 `KV.incr` 失败)。`Toaster` 提示："当前服务忙，请稍候再试"（2.3.0）。
    - **状态 3：查看历史服务 (Done)** (当用户从左侧栏加载 `service_id`)
      - `Title`: 显示 `job.title`。
      - `Tabs`: **"Step 1: 匹配度"** | **"Step 2: 改简历"** | **"Step 3: 面试"**（FR-2.5）。
      - **Tab 1 (Match)**:
        - `Content`: 只读，显示 `match` 任务的结果。
        - `Footer`: `Button`: "下一步：帮我改简历" (如果 `customize` 任务未开始)。
      - **Tab 2 (Customize)**:
        - `Content`: 如果未开始，显示 `Button` "生成定制化简历" (触发 `customizeResumeAction`)。
        - `Content`: 如果已完成，显示**“Markdown 编辑器”**（左侧 `Textarea`，右侧 `iframe` 预览 PDF）(FR-6.2)。
        - `Footer`: `Button (secondary)` "保存修改" | `Button (primary)` "导出 PDF" (FR-6.3)。
      - **Tab 3 (Interview)**:
        - `Content`: 如果未开始 (且 Step 2 已完成)，显示 `Button` "生成面试 Tips" (触发 `generateInterviewTipsAction`)。
        - `Content`: 如果已完成，只读，显示 `interview` 任务的流式结果。
- **移动端适配 (How - 移动端)**：
  - **Column 1 (Sidebar)**：**完全隐藏**。
  - **Header**：添加一个顶部 `Header`。
    - `Left`: "汉堡"菜单 `Button` (用于滑出 `Sidebar` 抽屉)。
    - `Right`: `Badge` (金币余额) | `UserAvatar` (进入 `/profile`)。
  - **Column 2 (Main)**：**占满 100% 宽度**。
  - **Markdown 编辑器**：在移动端，"左右布局" 体验很差。应**降级**为 `Tabs`："编辑 Markdown" | "预览 PDF"。

---

# 主题 2.6：应用设计系统 (Design System) 与 UI 规范

**致 AI IDE / 开发伙伴**：
本文档是实现「主题 2.5：页面设计」的**最高设计规范**。我们的目标不是“堆叠组件”，而是“注入设计基因”。你必须遵循以下所有规范，以确保 Web App 具备**专业 (Professional)**、**高效 (Efficient)** 和 **可信赖 (Trustworthy)** 的视觉个性。

---

### 1. 核心设计个性 (Design Personality)

- **原则**：我们正在构建一个“工具型” AI 应用。功能性和清晰度优先于一切。
- **规范**：
  - **专业 (Professional)**：界面干净、信息层级分明、无多余动效。
  - **高效 (Efficient)**：核心操作（上传、创建）必须在视觉上最突出。
  - **可信赖 (Trustworthy)**：所有异步反馈（`Toaster`, `Progress`, `Badge`）必须清晰、及时、准确。

### 2. 布局与间距 (Layout & Spacing)

- **黄金法则**：**间距（Spacing）是组织信息的第一工具，而不是边框（Borders）**。
- **规范 (AI IDE 必须遵守)**：
  - **基础单位**：严格遵循 `tailwind` 的 `4px` 栅格（例如 `p-4` = 16px, `p-6` = 24px）。
  - **卡片（`Card`）**：
    - `Card` 内部 padding **必须**使用 `p-6` (24px)，以保证内部元素的“呼吸感”。
    - `Card` 之间的间距（例如 `Profile Page` 的两个资产卡片）**必须**使用 `gap-6` 或 `gap-8` (24px - 32px)，间距要大于卡片内部间距。
  - **元素组（Element Groups）**：
    - 紧密相关的元素（如 `Label` 和 `Input`）之间的间距**必须**小（例如 `gap-2` 或 `gap-4`）。
    - 在 `Card` 内部，使用**间距**来分隔元素组，而不是使用 `<hr>` 线条。

### 3. 色彩规范 (Color Palette)

- **黄金法则**：在灰度下设计（Design in Grayscale）。限制色彩使用，用色阶构建层级。
- **规范 (AI IDE 必须遵守)**：
  - **基础**：严格使用 `shadcn/ui` 基于 HSL 和 CSS 变量的默认色彩系统。
  - **主色 (Primary)**：选择 `Blue` (蓝色系) 作为 `primary` 颜色。它代表“专业”和“可信赖”。**仅用于**核心 `Button` 和 `Link`。
  - **灰色 (Grays)**：
    - **绝不**使用纯黑 (`#000`) 或纯灰 (`#888`)。
    - **主标题/正文**：使用 `text-foreground` (例如 `slate-900`)。
    - **辅助文字**：**必须**使用 `text-muted-foreground` (例如 `slate-500`)。这用于所有 `Card` 的描述性文字、`Input` 下的提示文字。
  - **背景 (Backgrounds)**：
    - **页面背景**：`bg-background` (例如 `slate-50` 或 `white`)。
    - **容器背景**：`bg-card` (例如 `white` 或 `slate-100`)。我们**必须**利用这两个背景色的微妙差异来构建视觉层级。
  - **语义色 (Semantic)**：
    - `destructive` (Red): 仅用于危险操作（例如删除）。
    - `warning` (Yellow/Orange): **必须**用于“金币不足，转入免费队列”的 `Toaster` 提示。
    - `success` (Green): 用于“简历解析成功”等积极反馈。

### 4. 字体与排版 (Typography)

- **黄金法则**：通过“字重、大小、颜色”的组合来拉开排版层级，而不是只靠“大小”。
- **规范 (AI IDE 必须遵守)**：
  - **字体**：使用 `shadcn/ui` 默认配置（`Geist` / `Inter` / 系统 `sans-serif` 字体）。
  - **层级 (Hierarchy)**：
    - **`H1/H2` (页面/卡片大标题)**：
      - `tailwind`: `text-2xl lg:text-3xl`, `font-semibold`, `tracking-tight` (收紧字距)。
      - `color`: `text-foreground`。
      - **行距**：**必须**收紧 (`leading-tight` 或 `leading-snug`)。
    - **`Body` (正文 / AI 输出)**：
      - `tailwind`: `text-base`。
      - `color`: `text-foreground`。
      - **行距**：**必须**放宽 (`leading-relaxed` 或 `1.7`) 以保证 AI 大段文字的可读性。
    - **`Muted` (辅助描述)**：
      - `tailwind`: `text-sm`。
      - `color`: `text-muted-foreground`。
      - **应用场景**：`Card` 的描述、`Input` 下的提示、`Footer` 文字。

### 5. 边界与分隔 (Borders & Separation)

- **黄金法则**：**边框 (Borders) 是最后的手段**。过度使用边框会使界面“廉价”且“繁忙”。
- **分隔的优先级 (AI IDE 必须遵守)**：
  1.  **第一选择：使用间距 (Spacing)**。例如用一个 `gap-8` (32px) 的空白区域来分隔两个 `Card`。
  2.  **第二选择：使用背景色 (Backgrounds)**。例如 `bg-card` (白色) 浮在 `bg-background` (灰色) 之上，天然形成了分隔。
  3.  **第三选择：使用阴影 (Shadows)**。`shadcn/ui` 的 `Card` 自带了柔和的阴影，这是比“边框”更高级的分隔。
  4.  **最后选择：使用边框 (Borders)**。**仅限于**：
      - `Input`, `Textarea` (用户输入区域)。
      - `Table` 内部的行分隔。
      - **必须**使用 `shadcn/ui` 的 `border` 颜色 (例如 `slate-200`)，**绝不**使用 `border-black`。

### 6. 核心组件应用规范 (Component Rules)

- **原则**：`shadcn/ui` 是我们的“乐高积木”，`Refactoring_UI_Design_Rules.md` 是我们的“拼搭说明书”。
- **规范 (AI IDE 必须遵守)**：
  - **`Button`**：
    - `Primary` (主色): **每个视图（View）中只允许 1-2 个**。用于最核心的操作（例如“开始分析”、“保存修改”）。
    - `Secondary` (灰色): 用于次要操作（例如“替换文件”、“导出 PDF”）。
    - `Ghost` (透明): 用于非关键操作（例如 `Sidebar` 中的历史记录项）。
  - **`Card`**：
    - 这是我们 App 的**核心布局容器**。`Profile Page` 的资产卡片、`Workbench` 的 AI 输出结果，**必须**放在 `Card` 中，以利用 `bg-card`, `shadow`, `p-6` 提供的视觉分隔和呼吸感。
  - **`Toaster` (轻提示)**：
    - **必须**用于所有**非阻塞**的系统反馈（例如“金币不足，已转入免费队列”、“简历解析失败，金币已退回”、“当前服务忙，请稍候再试”）。
  - **`Alert`**：
    - **必须**用于**阻塞性**或**前置**提示。
    - 例如：`Workbench` 中，如果用户未上传简历，在 `Textarea` 上方**必须**显示一个 `Alert (variant: "default")`，提示用户“请先前往「个人主页」上传简历”。
  - **`Badge`**：
    - 用于**状态**显示。例如 `Profile Page` 中，简历文件旁的 `Badge (variant: "outline")` 显示 "PENDING" 或 "COMPLETED"。

---

# 主题 2.7：交互与状态设计指南

### 1. 核心原则：管理异步焦虑 (Managing Async Anxiety)

我们的 App 有两种核心异步模式（基于 M6）：

1.  **轮询 (Polling)**：用于“资产流”（M8 `resume`）和“批处理流”（M10 `customize`）。用户**不**在页面干等。
2.  **流式 (Streaming)**：用于“核心服务流”（M9 `match`, `interview`）。用户**正在**页面积极等待。

我们的 UI **必须**清晰地区分这两种状态。

### 2. “五态”设计系统：定义 UI 状态

AI IDE 在编码时，**必须**为每一个核心交互（如“上传简历”按钮、“匹配度分析”卡片）设计以下五种状态：

1.  **Idle (空闲态)**：

    - **视觉**：`Button` (primary) 正常显示 (例如 "开始分析")。
    - **规范**：这是默认状态。

2.  **Queued (排队态)**：

    - **视觉**：
      - `Button` 变为 `disabled`。
      - `Toaster` (轻提示) 弹出："（免费队列）任务已提交，正在排队..."
      - **(核心)** `Workbench` 左侧 `Sidebar` 的历史记录项旁边，出现一个 `Badge (variant="outline")` 显示 "排队中"。
    - **规范**：这是 `Server Action` 立即返回 `success`，但 `sse-stream` 尚未收到第一个 `token` 时的状态 (针对流式任务)。

3.  **Processing (处理中/轮询中)**：

    - **视觉 (流式 - M9)**：
      - `Card` 容器出现。
      - AI 响应以 **Markdown 流**的形式实时渲染在 `CardContent` 中。
      - `Button` (例如 "帮我改简历") 保持 `disabled`。
    - **视觉 (轮询 - M8/M10)**：
      - `Card` 容器出现一个 `Progress` 组件（`shadcn/ui`）和提示文本：“正在为您解析简历，这可能需要 1-2 分钟...”。
      - `Sidebar` 中的 `Badge` 变为 "解析中..."。

4.  **Success (成功态)**：

    - **视觉**：
      - `Progress` 消失。`CardContent` 渲染**最终结果**（例如 `customize` 的 Markdown 编辑器）。
      - `Sidebar` 的 `Badge` 消失（或变为绿色 `Check` 图标）。
      - `Toaster` (success) 弹出："简历解析完成！"。
      - 下一步的 `Button` (例如 "帮我改简历") 变为 `enabled`。

5.  **Failed (失败态)**：
    - **视觉**：
      - `Progress` 消失。
      - `CardContent` 替换为 `Alert (variant="destructive")` 组件。
      - `AlertTitle`: "任务执行失败"。
      - `AlertDescription`: "（从 SSE 或 Polling 返回的错误信息）。金币已自动退回您的账户。"
      - `Button` (例如 "开始分析") 变为 `enabled`，允许用户重试。

### 3. “情感化”设计：空状态 (Empty States)

**目标**：解决“求职主题” 的适配问题。求职是焦虑的，我们的 UI 应该是**鼓励性**和**引导性**的。

**AI IDE 规范 (M8/M9)**：

1.  **`Profile Page` 空状态 (M8)**：

    - 当用户**首次**进入 `Profile`，**必须**高亮“个人通用简历”的 `Card`。
    - `Card` 内**不应**只是一个上传框，而应包含：
      - `Icon`: (例如 `FileText` 图标)。
      - `Title`: "上传你的通用简历"。
      - `Description (text-muted-foreground)`: "这是 AI 助手为您服务的第一步。一份好的简历是成功求职的基石。"

2.  **`Workbench Page` 空状态 (M9)**：
    - 当 `Sidebar` 的“历史记录”为空时，中间的主工作区**不应**只是一个输入框。
    - **必须**展示一个引导性 `Card`，内容为：
      - `Icon`: (例如 `Sparkles` 图标)。
      - `Title`: "欢迎使用 AI 求职助手"。
      - `Description`: "请从粘贴一份你感兴趣的岗位描述（JD）开始。AI 将为您分析匹配度，并助您定制简历。"

### 4. 移动端专项优化 (Mobile-First Async)

**目标**：确保 M6 的异步体验在移动端 同样“顺畅”。

**AI IDE 规范 (M10)**：

1.  **轮询 (Polling)**：

    - `Profile Page`（资产上传） 是“非即时”的。
    - **规范**：在移动端，用户提交上传后，**可以**离开页面。状态更新**必须**依赖 `Sidebar`（`Drawer` 模式） 或 `Profile Page` 卡片上的 `Badge` 状态（`PENDING` -> `COMPLETED`）。**不要**使用全屏 `Progress` 强制用户等待。

2.  **流式 (Streaming)**：
    - `Workbench`（`match`/`interview`）是“即时”的。
    - **规范**：
      - 当 SSE 开始流式输出时，页面**必须**自动滚动到 `CardContent` 区域。
      - `CardContent`（显示 AI 响应的区域）**必须**设置一个最大高度（例如 `max-h-[60vh]`）并启用 `overflow-y-scroll`，确保用户在移动设备上可以滚动 AI 的答案，**而不是**滚动整个网页。

---
