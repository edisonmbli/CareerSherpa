**Vercel 的 Free Tier (Hobby Plan) 是可以使用 Vercel Blob 服务的**。
目前（截至 2024 年），Hobby 计划包含 250MB 的存储空间和每月 5GB 的数据传输量，这对于小型项目或测试验证来说通常是足够的。

针对你的核心痛点——**“如何兼顾本地开发的便捷性（读写本地磁盘）与线上环境的可用性（使用 Vercel Blob）”**，最佳实践是使用 **“策略模式” (Strategy Pattern)** 或者简单的 **环境抽象层**。

### 解决方案概览

我们将创建一个统一的 `UploadService`（上传服务）。

1.  **本地环境 (Development):** 代码检测到是开发环境时，直接将文件写入项目的 `public` 文件夹。这样你可以立即通过 `http://localhost:3000/uploads/xxx` 访问图片，无需消耗云端流量，且速度极快。
2.  **生产环境 (Production):** 代码检测到是生产环境时，自动切换逻辑，调用 `@vercel/blob` SDK 将文件上传到云端，并返回云端 URL。

---

### 具体实现步骤 (以 Next.js App Router 为例)

#### 第一步：安装依赖

你需要安装 Vercel Blob 的 SDK。

```bash
npm install @vercel/blob
```

#### 第二步：编写统一的上传工具函数

并在你的项目工具库中（例如 `lib/upload.ts`）创建一个封装函数。这是实现“兼顾”的核心代码。

```typescript
// lib/upload.ts
import { put } from '@vercel/blob'
import path from 'path'
import fs from 'fs/promises'

export async function uploadFile(file: File, filename: string) {
  // 判断当前环境
  const isProduction = process.env.NODE_ENV === 'production'

  if (isProduction) {
    // === 生产环境：上传到 Vercel Blob ===
    // 'public' 访问级别意味着文件可以公开访问
    const blob = await put(filename, file, {
      access: 'public',
    })

    // 返回 Vercel Blob 的完整 URL
    return blob.url
  } else {
    // === 本地环境：保存到本地磁盘 ===

    // 1. 确定保存路径 (例如保存到 public/uploads)
    // 注意：需要确保 public/uploads 文件夹已存在
    const uploadDir = path.join(process.cwd(), 'public', 'uploads')

    // 确保目录存在
    try {
      await fs.access(uploadDir)
    } catch {
      await fs.mkdir(uploadDir, { recursive: true })
    }

    const filePath = path.join(uploadDir, filename)

    // 2. 将 File 对象转换为 Buffer 以便写入磁盘
    const arrayBuffer = await file.arrayBuffer()
    const buffer = new Uint8Array(arrayBuffer)

    // 3. 写入文件
    await fs.writeFile(filePath, buffer)

    // 4. 返回本地访问的 URL
    // 假设你的本地服务跑在 localhost
    return `/uploads/${filename}`
  }
}
```

#### 第三步：在 API Route 中使用

无论在本地还是线上，你的业务逻辑代码（API Route）都不需要改变，它只需要调用上面的 `uploadFile` 即可。

```typescript
// app/api/upload/route.ts
import { NextResponse } from 'next/server'
import { uploadFile } from '@/lib/upload' // 引入刚才写的工具

export async function POST(request: Request) {
  try {
    const formData = await request.formData()
    const file = formData.get('file') as File

    if (!file) {
      return NextResponse.json({ error: 'No file uploaded' }, { status: 400 })
    }

    // 生成一个唯一文件名，防止重名覆盖
    const uniqueName = `${Date.now()}-${file.name}`

    // === 关键点：调用统一接口 ===
    // 这里不需要关心是本地还是线上，uploadFile 会自动处理
    const url = await uploadFile(file, uniqueName)

    return NextResponse.json({ url })
  } catch (error) {
    console.error('Upload error:', error)
    return NextResponse.json(
      { error: 'Internal Server Error' },
      { status: 500 }
    )
  }
}
```

---

### 重要配置与注意事项

为了让这套方案完美运行，你需要注意以下几点：

#### 1\. 本地 `.gitignore` 配置

既然本地开发会将文件保存到 `public/uploads`，你不希望这些测试图片被提交到 Git 仓库中。请在 `.gitignore` 文件中添加：

```text
# .gitignore
public/uploads/*
!public/uploads/.gitkeep
```

_(建议在 `public/uploads` 下放一个空的 `.gitkeep` 文件以保持文件夹结构)_

#### 2\. Vercel 环境变量

部署到 Vercel 后，你需要确保已经关联了 Blob Store。

- 在 Vercel Dashboard 中创建一个 Blob 数据库。
- 它会自动添加 `BLOB_READ_WRITE_TOKEN` 到你的环境变量中。代码中的 `put()` 函数会自动读取这个 Token。

#### 3\. 关于“大文件”的限制

这是 Vercel 架构的一个关键限制：

- **API 路由限制：** Vercel 的 Serverless Function (API Route) 请求体通常限制在 **4.5MB** 左右。
- **如果你的文件大于 4.5MB：** 上述通过 `POST` 发送到 API 的方法在 Vercel 上会失败（报错 413 Payload Too Large）。
- **解决方案：** 对于真正的大文件，推荐使用 **Client-side Uploads (客户端直传)**。即前端先向后端请求一个“上传授权”，然后前端直接把文件传给 Vercel Blob，不经过你的 API Server。

如果你需要处理超过 4MB 的文件，我可以为你提供“客户端直传”的代码示例，那也是支持本地/线上环境切换的。

---
