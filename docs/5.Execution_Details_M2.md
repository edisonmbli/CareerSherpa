### M2 落地指南 (致 AI IDE)

**目标**：构建“认证”与“金币”两大业务地基。
**核心规范**：严格遵循 `project_rules.md` 中定义的“DAL 规范” (Rule 4) 和“Neon Auth 最佳实践” (Rule 8.4)。

---

#### 任务 1：实现 Auth 封装 (`lib/auth/wrapper.ts`)

- **目标**：创建一个可复用的 Server Action 封装器，确保所有需要登录的 Action 都能安全获取 `userId`。
- **复用**：参考 `prototype` 中的 `lib/api/auth-wrapper.ts` 和 `lib/actions/auth.ts` 的逻辑。
- **文件**：`lib/auth/wrapper.ts`

<!-- end list -->

```typescript
// AI IDE: Create this file at lib/auth/wrapper.ts
import { auth } from '@job-assistant/authkit' // 假设的 Neon Auth/Clerk 客户端
import { db } from '@/lib/prisma' //
import { users_sync } from '@prisma/client'

export type AuthenticatedAction<TInput, TOutput> = (
  input: TInput,
  user: users_sync // 我们的 Neon Auth 用户模型
) => Promise<TOutput>

/**
 * 封装 Server Action，注入认证和用户数据
 * (Based on prototype auth-wrapper.ts)
 */
export function withAuth<TInput, TOutput>(
  action: AuthenticatedAction<TInput, TOutput>
) {
  return async (input: TInput): Promise<TOutput> => {
    // 1. 获取 Auth Session
    const session = await auth() // e.g., clerk.currentUser() or neon.auth.session()
    if (!session || !session.userId) {
      throw new Error('AuthenticationRequired: User is not authenticated.')
    }

    // 2. 从 users_sync 表获取我们的业务用户
    // 严格遵循 Rule 8.4.2: 总是检查 deleted_at
    const user = await db.users_sync.findFirst({
      where: {
        id: session.userId,
        deleted_at: null,
      },
    })

    if (!user) {
      throw new Error('UserNotFound: User record not found or is deleted.')
    }

    // 3. 注入 user 对象，执行业务逻辑
    try {
      return await action(input, user)
    } catch (error) {
      // TODO: M7 - M11 - Analytics tracking
      console.error('AuthenticatedAction Error:', error)
      throw error // Re-throw for Server Action to handle
    }
  }
}
```

---

#### 任务 2 & 3：实现原子化 Quota DAL 和“延迟初始化”

- **目标**：构建 M2 的核心 `lib/dal/quotas.ts`。
- **规范**：严格遵循 Project Rule 4 (DAL)。
- **文件**：`lib/dal/quotas.ts`

<!-- end list -->

```typescript
// AI IDE: Create this file at lib/dal/quotas.ts
import { db } from '@/lib/prisma'
import { Prisma } from '@prisma/client'

// 从环境变量或配置中读取初始赠送金币
const INITIAL_FREE_QUOTA = parseInt(process.env.INITIAL_FREE_QUOTA || '8', 10)

/**
 * 任务 3: 延迟初始化 - 获取或创建用户的金币账户
 * (Requirement 2.1.4 & 2.2.1)
 */
export const getOrCreateQuota = async (userId: string) => {
  const existingQuota = await db.quota.findUnique({
    where: { userId },
  })

  if (existingQuota) {
    return existingQuota
  }

  // (Lazy Initialization)
  // 用户首次操作，创建账户并赠送金币
  try {
    const newQuota = await db.quota.create({
      data: {
        userId: userId,
        balance: INITIAL_FREE_QUOTA,
      },
    })
    // TODO: M7 - M11 - trackEvent('USER_QUOTA_CREATED')
    return newQuota
  } catch (error) {
    // 捕获并发冲突：万一两个操作同时尝试创建
    if (
      error instanceof Prisma.PrismaClientKnownRequestError &&
      error.code === 'P2002'
    ) {
      return db.quota.findUniqueOrThrow({ where: { userId } })
    }
    throw error
  }
}

/**
 * 任务 2: 原子化扣减金币
 * (Requirement 2.2.4)
 */
export const deductQuota = async (
  userId: string,
  amount: number,
  tx: Prisma.TransactionClient = db
) => {
  if (amount <= 0) return { success: true }

  const result = await tx.quota.updateMany({
    where: {
      userId: userId,
      balance: {
        gte: amount, // 核心：确保余额充足
      },
    },
    data: {
      balance: {
        decrement: amount,
      },
    },
  })

  // updateMany 不会抛出“未找到”错误，而是返回 count
  if (result.count === 0) {
    // 扣费失败（余额不足）
    return { success: false, error: 'InsufficientQuota' }
  }

  // TODO: M7 - M11 - trackEvent('QUOTA_DEDUCTED')
  return { success: true }
}

/**
 * 任务 2: 原子化返还/增加金币
 * (Requirement 2.2.4)
 */
export const addQuota = async (
  userId: string,
  amount: number,
  tx: Prisma.TransactionClient = db
) => {
  if (amount <= 0) return

  const updatedQuota = await tx.quota.update({
    where: {
      userId: userId,
    },
    data: {
      balance: {
        increment: amount,
      },
    },
  })

  // TODO: M7 - M11 - trackEvent('QUOTA_ADDED')
  return updatedQuota
}

/**
 * 检查余额（非事务性）
 */
export const checkBalance = async (userId: string, amount: number) => {
  const quota = await getOrCreateQuota(userId)
  return quota.balance >= amount
}
```

---

#### 任务 4：实现状态轮询 API (`/api/task-status`)

- **目标**：创建一个**安全**、**轻量**的状态查询 API。
- **规范**：此 API **必须**使用 `withAuth` 封装器。
- **文件**：`app/api/task-status/route.ts` (使用 API Route Handler 而非 Server Action，以便于 `GET` 请求)

<!-- end list -->

```typescript
// AI IDE: Create this file at app/api/task-status/route.ts
import { NextResponse } from 'next/server'
import { db } from '@/lib/prisma'
import { auth } from '@job-assistant/authkit' // 假设的 Auth 客户端

// 这是一个 GET 路由，但我们用 auth() 检查 session
export async function GET(request: Request) {
  // --- 安全锁 1: 认证 ---
  const session = await auth()
  if (!session || !session.userId) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }
  const { userId } = session

  const { searchParams } = new URL(request.url)
  const taskId = searchParams.get('taskId')
  const taskType = searchParams.get('taskType') // e.g., 'resume', 'customize'

  if (!taskId || !taskType) {
    return NextResponse.json(
      { error: 'Missing taskId or taskType' },
      { status: 400 }
    )
  }

  let statusRecord

  try {
    // --- 路由逻辑 ---
    switch (taskType) {
      case 'resume':
        statusRecord = await db.resume.findUnique({
          where: { id: taskId, userId: userId }, // <-- 安全锁 2: 所有权检查
          select: { status: true },
        })
        break

      case 'detailed_resume':
        statusRecord = await db.detailedResume.findUnique({
          where: { id: taskId, userId: userId }, // <-- 安全锁 2: 所有权检查
          select: { status: true },
        })
        break

      case 'service_match': // M8 将轮询 Service
        const service = await db.service.findUnique({
          where: { id: taskId, userId: userId }, // <-- 安全锁 2: 所有权检查
          select: {
            job: { select: { status: true } },
            match: { select: { status: true } },
          },
        })
        if (service) {
          // 复杂状态：如果 Job 是 PENDING，则任务是 PENDING
          if (service.job?.status === 'PENDING')
            statusRecord = { status: 'PENDING' }
          // 否则，采用 Match 的状态
          else statusRecord = service.match
        }
        break

      case 'customize': // M9
        statusRecord = await db.customizedResume.findUnique({
          where: { id: taskId, service: { userId: userId } }, // <-- 安全锁 2: 深度所有权检查
          select: { status: true },
        })
        break

      // M9 interview 将使用 SSE，无需轮询

      default:
        return NextResponse.json({ error: 'Invalid taskType' }, { status: 400 })
    }

    if (!statusRecord) {
      return NextResponse.json(
        { error: 'Task not found or permission denied' },
        { status: 404 }
      )
    }

    // 成功返回（这是一个非常轻量的响应）
    return NextResponse.json({ status: statusRecord.status })
  } catch (error) {
    console.error(`TaskStatusError (t:${taskType}, id:${taskId}):`, error)
    return NextResponse.json(
      { error: 'Internal Server Error' },
      { status: 500 }
    )
  }
}
```

---

**M2 交付物：**

1.  `lib/auth/wrapper.ts` (认证封装)
2.  `lib/dal/quotas.ts` (金币 DAL)
3.  `app/api/task-status/route.ts` (安全轮询 API)

为 M7 (`uploadResumeAction`) 和 M8 (`createServiceAction`) 奠定坚实的业务基础。

---

### 深度思考记录：关于“状态轮询 API”的必要性与风险评估

你提出的担忧非常到位，这三点（用途、安全、性能）正是架构选型时必须权衡的。

**1. 它的用途是什么？(Why is it necessary?)**

- **答案**：它是我们新异步架构（`QStash` + Serverless）的\*\*“神经末梢”\*\*。
- **详细解释**：
  - 在我们的新流程（M7、M8）中，当用户上传简历或改写简历时，Server Action 会把这个耗时任务（例如 30 秒）交给 QStash，然后**立即**返回响应给前端。
  - 此时，前端（浏览器）不知道这个后台任务什么时候完成。
  - **轮询 API (Polling) 就是前端用来反复询问：“那个 ID 为 `task-xyz` 的简历解析任务，完成了吗？”**
  - 这是 Vercel 架构下实现异步 UI 更新的**标准、轻量且最可靠**的方案，用于所有“非流式”(non-SSE) 的任务（如简历解析 `resume_summary`、简历定制 `customize`）。

**2. 它的安全风险如何？(Hack Risk)**

- **答案**：风险**完全可控**。我们将通过“认证”+“授权”两把锁来保护它。
- **详细解释**：
  - **锁 1 (认证)**：此 API 路由**绝不**是公开的。它将 100% 被我们 M2 的 `withAuth` 封装器 保护。未登录的黑客连访问它的资格都没有。
  - **锁 2 (授权/所有权)**：API 逻辑会进行**所有权**检查。`GET /api/task-status?taskId=abc` 不仅要检查用户是否登录，还要检查 `taskId=abc` 这条记录的 `userId` **是否等于**当前登录的 `userId`。
  - **结论**：用户 A **永远**无法查询到用户 B 的任务状态。

**3. 它的性能风险如何？(Vercel Free Tier)**

- **答案**：风险极低，**是我们 Vercel 架构下的最优解**。
- **详细解释**：
  - **Vercel 的计费模型**：Vercel Free Tier **最怕的不是“调用次数”，而是“函数执行时长”**。一个执行 15 秒的函数（比如旧架构的同步 LLM 调用）对资源的消耗，远大于 100 个执行 100 毫秒的函数。
  - **API 的轻量性**：我们的轮询 API **极其轻量**。它只执行一次数据库 `SELECT status FROM resumes WHERE id = ?` 查询。它**不调用 LLM**，**不执行复杂计算**。它的执行时间通常在 100-300 毫秒之间，对 Vercel 资源消耗极小。
  - **“智能轮询”**：AI IDE 在 M7 实现前端时，不会“疯狂”轮询。我们会采用**指数退避**策略（Exponential Backoff）：例如在第 2s, 4s, 8s, 16s... 时查询，大大减少总调用次数。

**总结**：`task-status` API 是我们实现**真异步、非阻塞**用户体验的**关键基建**，安全且性能风险可控。

---

### 本轮交付

- 新增认证封装
  - 文件： lib/auth/wrapper.ts
  - 作用：统一的 Server Action 封装器，获取 Stack Auth 会话并加载 neon_auth.users_sync 有效用户（过滤 deleted_at ），将用户对象注入你的业务函数。
- 新增 Quota DAL（原子化、延迟初始化）
  - 文件： lib/dal/quotas.ts
  - 能力：
    - getOrCreateQuota(userId) ：延迟初始化，首次操作自动创建余额，默认来自 INITIAL_FREE_QUOTA （默认 8，可通过环境变量覆盖）。
    - deductQuota(userId, amount, tx?) ：原子扣减，使用 updateMany 保证余额充足才扣减。
    - addQuota(userId, amount, tx?) ：原子返还/增加。
    - checkBalance(userId, amount) ：获取余额（懒初始化）并判断是否充足。
- 新增任务状态轮询 API
  - 路由： app/api/task-status/route.ts
  - 认证：使用 Stack Auth 会话；所有查询都进行“所有权”检查（ where: { id, userId } ）。
  - 支持查询：
    - resume → Resume.status
    - detailed_resume → DetailedResume.status
    - service_match → 当 Job.status === PENDING 时返回 PENDING ，否则返回 Match.status
    - customize → CustomizedResume.status （附带 service 用户所有权检查）
- 嵌入维度校准
  - 文件： lib/llm/embeddings.ts
  - 变更：将默认维度从 1536 调整为 2048 ，并在调用 GLM Embedding-3 时显式传递 dimensions: 2048 ，与当前 schema.prisma 保持一致（GLM embedding-3 默认支持 2048 维度，参考官方文档： https://docs.bigmodel.cn/cn/guide/models/embedding/embedding-3 ）。

### 单元测试

- 测试文件
  - tests/auth-wrapper.test.ts ：验证认证封装器在“已登录/未登录/用户记录不存在”三种情形下的行为。
  - tests/quotas.test.ts ：覆盖延迟初始化、扣费成功/失败、返还与余额检查。
  - 保持既有 tests/idempotency.test.ts 工作正常（我修复了其模块解析，小改 lib/idempotency.ts 的导入路径到 @/lib/dal ，以匹配现有 mock）。
- 运行
  - 命令： npm run test
  - 结果：当前三个测试套件全部通过（21/21）。

### 如何使用

- 认证封装
  - 适用于所有需要用户身份的 Server Actions。示例：
    - lib/auth/wrapper.ts
      - export function withAuth(action)
      - 用法：
        - const action = withAuth(async (input, user) => { /_ your logic _/ })
        - 若未登录：抛出 AuthenticationRequired
        - 若 users_sync 未找到或软删除：抛出 UserNotFound
- Quota DAL（原子化）
  - 入口： lib/dal/quotas.ts
  - 常见流程：
    - 在 Server Action 中先 await getOrCreateQuota(userId) 做懒初始化；
    - 再 await deductQuota(userId, cost) 保证扣费原子性（你可以传入事务 tx ，与后续入队/写日志放在一组事务里）；
    - 任务失败时在 Worker 侧 await addQuota(userId, cost) 返还。
- 任务状态轮询 API

  - GET api/task-status?taskId=<id>&taskType=<type>
  - taskType 允许值： resume / detailed_resume / service_match / customize / interview
  - 返回： { status: 'PENDING' | 'COMPLETED' | 'FAILED' }
  - 权限：仅允许当前会话用户查询自己的任务；否则返回 404 。

### 重要对齐点

- Schema 一致性
  - 当前 prisma/schema.prisma 已是 M1 新版（ Quota.balance 、 Service + Job/Match/CustomizedResume/Interview 、 AsyncTaskStatus ），我所有实现均基于此结构。
- 向量维度

  - 已统一为 2048 ，并与 KnowledgeEntry.embedding Unsupported("vector(2048)") 一致；嵌入生成时也将 dimensions 显式传入，避免维度不匹配引起检索失败或插入失败。

### 设计取舍与说明

- 认证封装：虽然你已有 lib/actions/auth-wrapper.ts ，但按 M2 交付要求我新增 lib/auth/wrapper.ts 以“Server Actions first”的统一入口。这样后续 M8/M9 的 Action 可以更清晰地复用，不与 API 包装器混淆。
- Quota DAL：我单独提供 lib/dal/quotas.ts ，不复用旧的 lib/quota/atomic-operations.ts 中的“旧字段（initialGrant/used/remaining）”语义，避免混乱。新 DAL 基于 balance 字段的简单、可验证事务语义，更贴合 M2 的最小地基目标。
- 轮询 API：采用极轻量的 SELECT + 所有权检查，避免 Vercel Free/Pro 条件下长执行任务风险；配合前端指数退避策略即可实现良好的用户感知。
