# Neon Development 到 Production 的 Schema 迁移指南

> [!IMPORTANT]
> 本文档基于 Prisma 6.x + Neon Serverless PostgreSQL 的技术栈，适用于 Next.js 应用的数据库迁移场景。

## 概述

在 Neon 的分支开发模式下，我们通常在 **development 分支** 上进行 schema 变更，然后需要将这些变更安全地同步到 **production 分支**。本指南将详细说明这一过程的最佳实践。

```mermaid
flowchart LR
    subgraph Local["本地开发"]
        A[修改 schema.prisma] --> B[prisma migrate dev]
        B --> C[生成 migration 文件]
    end
    
    subgraph Dev["Development 分支"]
        C --> D[migration 应用到 dev DB]
        D --> E[测试验证]
    end
    
    subgraph Prod["Production 分支"]
        E --> F[切换 DATABASE_URL]
        F --> G[prisma migrate deploy]
        G --> H[生产环境更新完成]
    end
```

---

## 核心原则

| 命令 | 用途 | 适用环境 | 特性 |
|------|------|----------|------|
| `prisma migrate dev` | 开发时生成和应用迁移 | **仅 Development** | 可能重置数据库，生成 migration 文件 |
| `prisma migrate deploy` | 部署时应用已有迁移 | **Production / Staging** | 只应用 pending migration，不生成新文件，不重置数据 |

> [!CAUTION]
> **永远不要** 在生产环境运行 `prisma migrate dev`！该命令可能导致数据丢失。

---

## 标准迁移流程（正常情况）

> [!TIP]
> 如果你一直使用 `prisma migrate dev` 生成迁移，以下流程就是你需要的全部操作。简单、无痛。

### 前置条件

1. 确保 `.env.local` 中有两个数据库连接字符串（已注释标注）：
   - Production: `postgresql://neondb_owner:xxx@ep-billowing-snow-xxx-pooler...`
   - Development: `postgresql://neondb_owner:xxx@ep-twilight-snow-xxx-pooler...`

2. 确保本地 `prisma/migrations/` 目录已提交到 Git

---

### Step 1: 在 Development 分支生成 Migration

```bash
# 1. 确保 DATABASE_URL 指向 development 分支

# 2. 修改 schema.prisma 文件

# 3. 生成并应用 migration
npx prisma migrate dev --name <migration_name>
```

### Step 2: 验证并提交 Migration 文件

```bash
# 查看生成的 SQL
cat prisma/migrations/$(ls -t prisma/migrations | head -n 1)/migration.sql

# 提交到 Git
git add prisma/migrations/
git commit -m "feat(db): <description>"
```

### Step 3: 切换到 Production 并部署

```bash
# 1. 修改 .env.local，将 DATABASE_URL 指向 production

# 2. 检查并应用 migration
npx prisma migrate status
npx prisma migrate deploy

# 3. 验证
npx prisma migrate status  # 应显示 "Database schema is up to date!"
```

### Step 4: 恢复 Development 环境

```bash
# 将 DATABASE_URL 切换回 development 分支
```

---

## 完整命令序列（Checklist）

```bash
# ====== Development 阶段 ======
# 确保 DATABASE_URL 指向 development
npx prisma migrate dev --name <migration_name>
git add prisma/migrations/
git commit -m "feat(db): <description>"

# ====== Production 部署阶段 ======
# 将 DATABASE_URL 切换为 production
npx prisma migrate status          # 检查 pending migrations
npx prisma migrate deploy          # 应用到 production
npx prisma migrate status          # 确认已全部应用

# ====== 恢复开发环境 ======
# 将 DATABASE_URL 切换回 development
```

---

## 异常场景：历史 Migration 文件被修改

> [!WARNING]
> 此场景仅在**历史迁移文件被修改**时发生，正常使用 `prisma migrate dev` 不会遇到此问题。

### 问题背景

早期项目使用 `prisma migrate diff --from-schema-datasource` 生成迁移，这会比较**当前数据库状态** vs **schema.prisma**，而非**迁移历史** vs **schema.prisma**。这导致生成的迁移包含**重复的约束定义**（如外键）。

当后续尝试运行 `prisma migrate dev` 时，shadow database 重放所有迁移会失败：

```
Error: P3006
Migration `xxx` failed to apply cleanly to the shadow database.
Error: constraint "xxx_fkey" already exists
```

### 解决方案

#### 1. 修复迁移文件（删除重复语句）

```bash
# 找到有问题的 migration 文件，删除重复的 ADD CONSTRAINT 语句
vim prisma/migrations/<timestamp>_<name>/migration.sql
```

#### 2. 更新 Checksum（Dev 和 Prod 都需要）

Prisma 在 `_prisma_migrations` 表中存储每个迁移文件的 SHA256 checksum。修改文件后需要同步更新：

```bash
# 计算新的 checksum
shasum -a 256 prisma/migrations/<timestamp>_<name>/migration.sql | awk '{print $1}'
```

然后在 **Dev** 和 **Prod** 数据库中执行：

```sql
UPDATE public._prisma_migrations 
SET checksum = '<new_checksum>'
WHERE migration_name = '<migration_name>';
```

#### 3. 继续正常迁移流程

```bash
npx prisma migrate dev --name <new_migration_name>
# 然后切换到 production 执行 migrate deploy
```

### 验证修复

```bash
# 此命令应成功，不再提示 "migration was modified"
npx prisma migrate status
```

---

## 最佳实践：避免历史问题

| ❌ 避免 | ✅ 推荐 |
|--------|--------|
| `prisma migrate diff --from-schema-datasource` | `prisma migrate dev` |
| 手动编辑已应用的 migration 文件 | 创建新的修复 migration |
| 在 production 运行 `migrate dev` | 只使用 `migrate deploy` |

> [!NOTE]
> 如果始终使用 `prisma migrate dev` 生成迁移，Checksum 问题永远不会发生。

---

## 特殊场景处理

### 场景 1: Enum 新增值

这是**最安全的变更类型**，PostgreSQL 的 `ALTER TYPE ... ADD VALUE` 不影响现有数据。

```sql
ALTER TYPE "public"."FailureCode" ADD VALUE 'NEW_VALUE';
```

### 场景 2: 新增可空字段

同样是安全的变更，现有记录的新字段值为 `NULL`。

```sql
ALTER TABLE "table_name" ADD COLUMN "new_column" TEXT;
```

### 场景 3: 新增非空字段（需要默认值）

需要提供默认值，否则迁移会失败：

```sql
ALTER TABLE "table_name" ADD COLUMN "new_column" TEXT NOT NULL DEFAULT 'default_value';
```

### 场景 4: 破坏性变更（删除列/重命名）

> [!WARNING]
> 破坏性变更需要**分阶段部署**（Expand and Contract 模式）：
> 1. **Expand**: 添加新列，双写数据
> 2. **Migrate**: 更新应用代码使用新列
> 3. **Contract**: 删除旧列

---

## 常见问题

### Q: 如果忘记在 development 生成 migration，直接在 production 运行会怎样？

A: `prisma migrate deploy` 只会应用存在于 `prisma/migrations/` 目录中的迁移文件。如果没有生成 migration 文件，production 不会有任何变更。

### Q: 如果 production 和 development 的 schema 不同步怎么办？

A: 运行 `npx prisma migrate status` 检查差异。如果 development 有未同步的变更，按本指南执行；如果 production 有手动变更，考虑使用 `prisma db pull` 同步 schema。

### Q: Migration 失败了怎么办？

A: 
1. 检查错误信息，修复 SQL 问题
2. 如果需要回滚，手动编写 rollback SQL（Prisma 不自动生成 rollback）
3. 在测试环境验证修复后再次部署

### Q: Neon 分支显示 "Idle" 无法连接怎么办？

A: Neon 的 Serverless 特性会在空闲后暂停计算。首次连接时会自动唤醒，可能需要等待几秒。如果持续无法连接，检查：
1. 连接字符串是否正确
2. 网络是否正常
3. Neon Console 中分支状态

---

## 参考资源

- [Prisma Migrate Overview](https://www.prisma.io/docs/concepts/components/prisma-migrate)
- [Neon + Prisma Migrations Guide](https://neon.tech/docs/guides/prisma-migrations)
- [Production Deployment Best Practices](https://www.prisma.io/docs/guides/deployment/deploy-database-changes-with-prisma-migrate)

---

## 成功案例记录

### 2026-01-08: FailureCode Enum 扩展

| 变更类型 | 对象 | 新增值 | 状态 |
|----------|------|--------|------|
| Enum 扩展 | `FailureCode` | `STREAM_EMPTY` | ✅ 已同步 |
| Enum 扩展 | `FailureCode` | `LLM_LOGIC_REFUSAL` | ✅ 已同步 |
| Enum 扩展 | `FailureCode` | `TEMPLATE_LEAKAGE` | ✅ 已同步 |
| Enum 扩展 | `FailureCode` | `EMPTY_RESPONSE` | ✅ 已同步 |

**Migration**: `20260108122916_add_failure_code_error_variants`

**特殊处理**: 由于历史 `m4_llm_usage_log_expansion` migration 文件包含重复外键约束，需要先删除重复行并更新 Dev/Prod 的 checksum 后才能成功迁移。此为一次性修复，后续迁移不再需要。

---

*最后更新: 2026-01-08*
