# 质量与性能调优规划 (Quality & Performance Tuning Plan)

## 1. 现状分析 (Current Status Analysis)

通过对 `lib/worker`、`app/[locale]/workbench` 及相关代码的深度摸底，以及对性能日志 `tmp/perf-timeline/cmilyci5500018oix0ejvjw8m.md` 的分析，我们发现项目在代码质量和性能方面存在显著问题。

### 1.1 代码质量问题 (Code Quality Issues)

1.  **Backend (`lib/worker/handlers.ts`)**:
    - **巨型文件**: `handlers.ts` 超过 2200 行，混合了路由、守卫、变量准备、执行、结果写入、错误处理等所有逻辑，维护成本极高。
    - **类型安全缺失**: 大量使用 `as any` 强制类型转换，绕过了 TypeScript 的检查，存在运行时错误风险。
    - **异常吞没**: 存在大量空的 `try-catch` 块 (e.g., `try { ... } catch {}`)，导致错误发生时无日志、无反馈，极难排查问题。
    - **逻辑硬编码**: 使用大量的 `if (templateId === '...')` 逻辑分支，缺乏设计模式（如策略模式）的应用，扩展性差。
2.  **Frontend (`app/[locale]/workbench/[serviceId]/page.tsx`)**:
    - **违反架构规范**: 在 Server Component 中直接调用 `prisma` (`db.service.findFirst`)，违反了 "Mandatory DAL Usage" 的项目原则。
3.  **通用问题**:
    - **Waterfall Code**: 存在大量不必要的串行 `await`，尤其是在数据获取和 LLM 准备阶段。

### 1.2 性能瓶颈 (Performance Bottlenecks)

基于日志分析，核心性能瓶颈如下：

1.  **Job Summary 和 OCR Extract 写入耗时异常 (~22s)**:
    - 日志显示 `worker_batch_write_summary_db_start`和`worker_batch_write_ocr_db_start` 到 `_end` 耗时约 22 秒。这远超正常的 DB 写入时间，疑似存在锁竞争、大对象处理效率低或不必要的同步操作。
2.  **Match 任务准备阶段耗时 (~5s)**:
    - `prepareStreamVars` 中，获取 Context (`getServiceSummariesReadOnly`) 耗时 ~1.2s。
    - RAG 检索 (`worker_stream_vars_rag_end`) 耗时 ~3.5s。
    - `worker_batch_finalize_end` 耗时 8s 以上。
    - **原因**: 上述操作均为**串行**执行，且 RAG 内部对 `queryA` and `queryB` 的检索也是串行的。
3.  **QStash 入队延迟 (~3.7s)**:
    - `pushTask` 耗时较长，影响了任务流转的及时性。
4.  **Service 创建链路冗长**:
    - `createServiceAction` 中包含 7+ 次串行的 DB 操作，导致首屏响应慢。

### 1.3 架构风险评估 (Architecture Review)

针对 "QStash + Worker + SSE" 架构的复杂性与运维风险评估：

1.  **架构合理性**: 在 Serverless (Vercel) 环境下，由于 Function Execution Timeout 限制（通常 10-60s），处理长时 LLM 任务（可能耗时 1-2 分钟）必须采用 **异步队列 (Queue)** 机制。结合 **SSE (Server-Sent Events)** 实现流式反馈是社区解决此类问题的标准范式 (Best Practice)。
2.  **复杂性来源**: 当前的复杂性并非来自架构模式本身，而是来自**实现细节**：
    - **手动锁管理**: 代码中手动处理 `acquireLock`/`releaseLock` 和 `bumpPending`，逻辑分散且易出错。
    - **状态分散**: 任务状态在 Redis、DB 和 SSE 消息之间流转，缺乏统一的状态机管理。
3.  **改进方向**:
    - **封装**: Phase 1 将通过策略模式封装这些底层逻辑，对上层业务隐藏复杂性。
    - **最佳实践**: 确保 Worker 幂等性，利用 QStash 的重试机制而非代码内重试。

---

## 2. 调优方案 (Optimization Plan)

我们将分三个阶段逐步推进优化。

### 2.1 Phase 1: 代码质量重构 (Refactoring for Quality)

**目标**: 消除技术债务，提升代码可维护性和稳定性，**不改变业务逻辑**。

1.  **重构 Backend Worker**:
    - **拆分 Handler**: 将 `lib/worker/handlers.ts` 拆分为独立的文件/模块，按 `TemplateId` (e.g., `job_match`, `job_summary`, `ocr_extract`) 分离逻辑。
    - **策略模式**: 引入 `WorkerStrategy` 接口，统一 `prepareVars`, `execute`, `writeResults` 的签名。
    - **类型修复**: 移除 `as any`，完善 `WorkerBody` 和 `Variables` 的 Zod 定义和 TS 类型。
    - **错误处理**: 移除所有空 `catch`，替换为统一的 `logError` 或结构化日志记录。
2.  **规范 Frontend 数据访问**:
    - 将 `app/[locale]/workbench/[serviceId]/page.tsx` 中的直接 DB 调用重构为调用 `lib/dal/services.ts` 中的 DAL 函数。

### 2.2 Phase 2: 性能深度优化 (Performance Tuning)

**目标**: 将关键路径耗时降低 50% 以上。

1.  **并行化 RAG 与 Context 获取 (Parallelize Context & RAG)**:
    - 在 `prepareStreamVars` 中，使用 `Promise.all` 并行执行 `getServiceSummariesReadOnly` 和 RAG 检索。
    - 在 RAG 检索内部，并行执行 `queryA` 和 `queryB` 的向量检索。
    - **预期收益**: Match 准备阶段耗时从 ~5s 降至 ~2s。
2.  **优化 Job Summary 和 OCR Extract 写入 (Optimize DB Writes)**:
    - 审查 `setJobSummaryJson` 及相关 DAL 代码，检查是否存在不必要的事务锁或大字段全量更新。
    - 考虑将非关键的后续动作（如 notify match task）与 DB 写入解耦（异步化）。
    - **预期收益**: DB 写入耗时从 ~22s 降至 <1s。
3.  **优化创建服务链路 (Optimize Service Creation)**:
    - 在 `createServiceAction` 中，将无依赖的 DB 操作（如 `getLatestResume`, `getLatestDetailedResume`, `getOrCreateQuota`）改为 `Promise.all` 并行执行。
    - **预期收益**: 创建服务响应速度提升 30%。
4.  **QStash 优化 (QStash Tuning)**:
    - 检查 `pushTask` 是否可以改为非阻塞（fire-and-forget），或者复用 HTTP 连接。

### 2.3 Phase 3: 清理与可观测性 (Cleanup & Observability)

**目标**: 在确认性能达标后，移除临时脚手架，建立长效监控。

1.  **日志清理**:
    - 在 Phase 1 & 2 完成并**验证通过后**，移除代码中大量的 `console.log`, `fs.writeFileSync` 等临时 debug 代码。
    - 移除 `markTimeline` 中过于细碎的埋点，仅保留关键节点的 SLA 监控。
2.  **规范化日志**:
    - 保留关键的 `logEvent` (结构化日志)，确保生产环境的可观测性。

---

## 3. 执行步骤 (Execution Steps)

1.  **Step 1 (Quality)**: 重构 `app/[locale]/workbench/[serviceId]/page.tsx`，修复 DAL 违规。
2.  **Step 2 (Quality)**: 重构 `lib/worker/handlers.ts`，拆分文件并修复 `try-catch`/`any` 问题。
    - 创建 `lib/worker/strategies/` 目录。
    - 定义 `WorkerStrategy` 接口。
    - 实现 `MatchStrategy`, `SummaryStrategy`, `OCRStrategy`。
    - 重写 `handlers.ts` 使用策略模式。
3.  **Step 3 (Perf)**: 优化 `prepareStreamVars`，实现 Context 与 RAG 的并行获取。
4.  **Step 4 (Perf)**: 深入排查并修复 `job_summary` DB 写入慢的问题。
5.  **Step 5 (Perf)**: 优化 `createServiceAction` 的并发逻辑。
6.  **Step 6 (Cleanup)**: 移除临时 Debug 日志。

请确认是否按照此计划开始执行。
