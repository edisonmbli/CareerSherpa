## 让模型只输出“结构化编辑指令/文档骨架+引用”，在应用侧合成成品，能显著减少输出 tokens 与延迟

你的两段式方案非常适合利用“减少生成 tokens”的最佳实践（你当前页面就强调：削减输出 token 往往线性降低时延与成本）。核心思想：第二步“定制简历”不让模型吐全量文本，而只让它输出“改写计划与精确的编辑操作”，由应用侧把“原始简历文本 + 编辑指令”合成最终版本。下面给出一整套在 Next.js 落地的可行方案与代码示例。

### 设计原则（紧扣“减少输出 tokens”）

- **让模型输出“最小可描述”的结果**：
  - 结构化编辑指令（JSON），而不是整段成品文本
  - 短句“要点/句式模板 + 指针”引用原文片段
  - 仅返回修改处的增量（diff/patch），不复述未改段
- **将“长文本组装/格式化”放在应用侧完成**
- **分阶段推理**：
  - 基础版分析：中等推理，输出结构化分析
  - 定制撰写：高推理，但只输出编辑指令/模板，整体 tokens 极小

### 内容建模：把简历变成“可打补丁”的文档

1.  **解析上传 PDF 为结构化文档（JSON）**
    - `sections`: Header, Summary, Experience[], Education[], Skills[], Projects[]
    - 每个段落/要点生成稳定的 `span_id`（比如基于内容 hash）
    - 保留原文 `text` 与 `metadata`（起止位置、token 计数、语言）
2.  **建立“可寻址路径”**
    - 使用 JSON Pointer 路径（如 `/experience/2/bullets/1`）
    - 或为每个 bullet 保存 `span_id`，便于引用

### 让模型输出哪种“最小结果”？

可选其一或组合：

- **JSON Patch**（RFC 6902）或 **JSON Merge Patch**：`replace`/`add`/`remove` 针对路径
- **片段级指令（推荐）**：
  - `type`: `rewrite` | `insert_after` | `delete` | `move`
  - `target`: `span_id` 或 `json_pointer`
  - `reason`: 简短解释（便于前端高亮与可回退）
  - `content`: 新文本或模板（保留 `{company}`、`{impact_metric}` 等占位符）
- **模板骨架 + 引用**：
  - 对 Summary/Highlights 仅输出 3–5 条模板句式与需填的变量键值（变量从已有简历/基础分析中引用）

这样，模型输出通常只有几百到几千字符，远低于全量简历。

### RAG/分析如何接入

- 二阶段时不要再次把整份简历与 JD 全文塞进上下文
  - 只带：基础版结构化分析输出（很短）+ 将被修改的目标片段原文（few-shot 上下文）
  - 对于需要补充的数据（量化成果等），只给检索到的最相关小片段（top-k，小摘要）

### Next.js 落地示例（TypeScript）

1.  **定义编辑指令 Schema（用于 Structured Outputs）**`// schemas/editPlan.ts`

    ```typescript
    export type EditOp =
      | {
          type: 'rewrite'
          target: { pointer?: string; spanId?: string }
          content: string
          reason?: string
        }
      | {
          type: 'insert_after'
          target: { pointer?: string; spanId?: string }
          content: string
          reason?: string
        }
      | {
          type: 'delete'
          target: { pointer?: string; spanId?: string }
          reason?: string
        }
      | {
          type: 'move'
          from: { pointer?: string; spanId?: string }
          to: { pointer?: string; spanId?: string }
          reason?: string
        }

    export interface EditPlan {
      summary: string // 简要说明修改思路
      ops: EditOp[] // 编辑操作列表（最小增量）
      templates?: {
        // 可选：句式模板（减少生成长度）
        summaryBullets?: string[] // 如："在 {company} 用 {tech} 将 {metric} 提升 {value}% ..."
      }
    }
    ```

2.  **Route：生成编辑指令（模型只“出方案”，不“出成品”）**`// app/api/resume/customize/route.ts`

    ```typescript
    import OpenAI from 'openai'
    import { NextRequest } from 'next/server'
    import { EditPlan } from '@/schemas/editPlan'

    const client = new OpenAI()

    export async function POST(req: NextRequest) {
      const { structuredResume, basicAnalysis, targets } = await req.json()
      // structuredResume: 解析后的 JSON（含 spanId / pointer）
      // basicAnalysis: 第一步基础分析结构化结果（短）
      // targets: 打算改写的范围（如 ["summary", "/experience/1/bullets/0"]）

      const devInstructions = `
    Formatting re-enabled
    你是资深职业顾问。基于给定的“基础分析”和“原始片段”，仅输出简历的“编辑指令”（JSON），不要直接给全文。
    
    - 目标：提升与 JD 的匹配度与可读性，量化业绩，保留事实，不编造。
    - 只编辑 targets 指定的范围；未提及的部分不要改。
    - 优先使用 rewrite/insert_after/delete，必要时 move。
    - 句子尽量短，内容具体；英/中文保持与原文一致。
      `

      // 聚焦最小上下文：仅带将被修改的片段原文，避免长上下文
      const focusedContext = extractFocusedContext(structuredResume, targets) // 你实现：按 pointer/spanId 取原文小段

      const input = [
        { role: 'developer', content: devInstructions },
        {
          role: 'user',
          content: `[BASIC_ANALYSIS]
    ${JSON.stringify(basicAnalysis, null, 2)}
    
    [STRUCTURED_RESUME_TARGET_SNIPPETS]
    ${JSON.stringify(focusedContext, null, 2)}
    
    [TARGETS]
    ${JSON.stringify(targets)}
    `,
        },
      ]

      const response = await client.responses.create({
        model: 'gpt-5',
        reasoning: { effort: 'high' }, // 强推理，但输出很短
        input,
        // 结构化输出：强制 JSON，减少冗余 tokens
        response_format: {
          type: 'json_schema',
          json_schema: {
            name: 'edit_plan',
            schema: {
              type: 'object',
              properties: {
                summary: { type: 'string' },
                ops: {
                  type: 'array',
                  items: {
                    oneOf: [
                      {
                        type: 'object',
                        properties: {
                          type: { const: 'rewrite' },
                          target: {
                            type: 'object',
                            properties: {
                              pointer: { type: 'string' },
                              spanId: { type: 'string' },
                            },
                          },
                          content: { type: 'string' },
                          reason: { type: 'string' },
                        },
                        required: ['type', 'target', 'content'],
                      },
                      {
                        type: 'object',
                        properties: {
                          type: { const: 'insert_after' },
                          target: {
                            type: 'object',
                            properties: {
                              pointer: { type: 'string' },
                              spanId: { type: 'string' },
                            },
                          },
                          content: { type: 'string' },
                          reason: { type: 'string' },
                        },
                        required: ['type', 'target', 'content'],
                      },
                      {
                        type: 'object',
                        properties: {
                          type: { const: 'delete' },
                          target: {
                            type: 'object',
                            properties: {
                              pointer: { type: 'string' },
                              spanId: { type: 'string' },
                            },
                          },
                          reason: { type: 'string' },
                        },
                        required: ['type', 'target'],
                      },
                      {
                        type: 'object',
                        properties: {
                          type: 'move',
                          from: {
                            type: 'object',
                            properties: {
                              pointer: { type: 'string' },
                              spanId: { type: 'string' },
                            },
                          },
                          to: {
                            type: 'object',
                            properties: {
                              pointer: { type: 'string' },
                              spanId: { type: 'string' },
                            },
                          },
                          reason: { type: 'string' },
                        },
                        required: ['type', 'from', 'to'],
                      },
                    ],
                  },
                },
                templates: {
                  type: 'object',
                  properties: {
                    summaryBullets: {
                      type: 'array',
                      items: { type: 'string' },
                    },
                  },
                },
              },
              required: ['ops'],
            },
          },
        },
        max_output_tokens: 1200, // 严控输出上限
        store: true, // 便于后续续接 previous_response_id
      })

      const plan = JSON.parse(response.output_text!) as EditPlan
      return new Response(JSON.stringify({ plan }), { status: 200 })
    }

    function extractFocusedContext(resume: any, targets: string[]) {
      // 根据 pointer/spanId 抽取被改区域的小片段，避免把整份简历放进上下文
      // 返回形如 { "/experience/1/bullets/0": "原文句子...", "summary": "原摘要..." }
      return {}
    }
    ```

### 应用侧合成（在服务器或前端）

- 使用 JSON Pointer/自定义指针应用 `ops`
- 必要时使用 `diff-match-patch` 之类库保证“软对齐”（原文轻微变化也能套用）`// lib/applyEditPlan.ts`

  ```typescript
  import { EditPlan } from '@/schemas/editPlan'
  import jp from 'jsonpointer' // JSON Pointer 工具

  export function applyEditPlan(structuredResume: any, plan: EditPlan) {
    const clone = structuredClone(structuredResume)
    for (const op of plan.ops) {
      if (op.type === 'rewrite') {
        const path = op.target.pointer!
        const prev = jp.get(clone, path)
        jp.set(clone, path, op.content)
      } else if (op.type === 'insert_after') {
        const path = op.target.pointer!
        const arrPath = path.replace(/\/\d+$/, '')
        const idx = Number(path.split('/').at(-1))
        const list = jp.get(clone, arrPath)
        list.splice(idx + 1, 0, op.content)
        jp.set(clone, arrPath, list)
      } else if (op.type === 'delete') {
        const path = op.target.pointer!
        const arrPath = path.replace(/\/\d+$/, '')
        const idx = Number(path.split('/').at(-1))
        const list = jp.get(clone, arrPath)
        list.splice(idx, 1)
        jp.set(clone, arrPath, list)
      } else if (op.type === 'move') {
        // 先取 from，再插入 to，最后删除 from（注意索引偏移）
      }
    }
    return clone
  }
  ```

合成后的结构化简历再经过渲染模板（React/PDF 生成）输出最终成品。前端可以高亮每条修改（依据 `reason` 与 `pointer`），提供逐条接受/撤销。

### 进一步压降 tokens 与延迟的技巧

- **控制输出格式最小化**：
  - 字段名短小（`ops`、`ptr`、`rid`…），必要时启用“语义短码”
  - 让模型输出“模板+变量表”，变量来自已有内容或基础分析
- **使用 `stop` 序列与 `max_output_tokens` 防止啰嗦**
- **强化“简洁”示例（few-shot）**：给出“正确示例：仅 3 条 rewrite，句子 ≤25 字”
- **前置本地摘要**：对过长 bullet 先在应用侧裁剪/摘要后再给模型重写
- **Prompt caching**：把稳定的开发者指令放在消息与参数最前，降低重复请求成本
- **`previous_response_id` + `store=true`**：二阶段直接复用第一阶段的推理上下文（当前文档推荐做法），减少重复“思考”消耗
- **并行化**：不同 section 的编辑指令可并行请求，最后在应用侧合并（避免 Batch，因为你需要交互式低时延）

### 质量与回退

- **结构化校验**：对 `plan` 走 JSON Schema 校验；路径有效性校验（`pointer` 存在、类型匹配）
- **幂等与可回滚**：每个 `op` 可撤销；保存原文快照与差异
- **Evals**：用“LLM‑as‑Judge + 人审小样本”评估可读性/忠实性；对“编造经历”一票否决
- **安全**：禁止模型新增未经上下文支撑的事实；若必须新增，让其产“待填变量清单”，由用户确认

### 总结

- 你的两段式流程天生适合“减少输出 tokens”的最佳实践：模型只产“编辑指令与模板”，应用侧拼装成品。
- 这样既把推理放在模型端（保证质量），又把大段文本生成搬到你的服务端（省时省钱可控可回退）。
- 在 Next.js 中通过 Structured Outputs + JSON Pointer/patch 的方案，可以非常稳健地落地并迭代。
