# 66. 简历头像存储方案迁移指南 (Avatar Storage Migration Guide)

## 1. 核心策略变更为：按需上传 (Lazy Upload)

### 策略概述

为了最大化节省 Vercel Blob 的存储与带宽成本，我们采用 **“按需上传”** 策略：

- **编辑/草稿阶段**：保持目前的 **本地存储 + Base64** 方案。不占用任何云端资源。
- **分享/发布阶段**：仅当用户点击“分享 (Share)”按钮时，才触发将头像上传至 Vercel Blob 的动作，并将数据库中的 Base64 替换为永久的 Blob URL。

---

## 2. 方案详细流程

### 2.1 编辑阶段 (Draft Mode)

用户在编辑器中上传头像时，**不直接上传到 Blob**。

1.  **前端处理**：
    - 将图片转换为 Base64。
    - **本地缓存**：写入 `localStorage` (Key: `user_avatar`)，保证当前设备刷新不丢。
    - **数据同步**：尝试将 Base64 写入数据库 (`resumeData.basics.photoUrl`)。
    - **关键限制**：为了防止数据库字段溢出或请求过大，建议在转 Base64 前对图片进行**强压缩** (建议限制在 100KB 以内)。如果图片过大导致 DB 写入失败，至少 `localStorage` 能兜底保证当前编辑体验。

### 2.2 分享阶段 (Share Mode)

这是本方案的核心改动点。在用户点击“生成分享链接”或“开启分享”时进行拦截处理。

**执行流程：**

1.  用户点击 `[Share]` / `[Publish]` 按钮。
2.  **检查头像状态**：前端检查 `resumeData.basics.photoUrl`。
    - 如果是空：跳过。
    - 如果是 `http/https` 开头的 URL：说明已上传过，跳过。
    - **如果是 Base64 (data:image...)**：触发上传流程。
3.  **自动上传 (Auto-Upload)**：
    - 前端显示 "Preparing shared resources..." loading 状态。
    - 调用 `uploadBase64ToBlob` Server Action。
    - 将 Base64 图片上传至 Vercel Blob。
    - 获取返回的 Blob URL。
4.  **更新数据**：
    - 将新的 Blob URL 更新到 `resumeData.basics.photoUrl`。
    - 保存简历数据到数据库。
5.  **完成分享**：生成分享链接并展示给用户。

---

## 3. 成本与体验分析

### 优势

1.  **成本极低**：绝大多数未完成或仅用于个人存档的简历不会消耗 Blob 额度。只有真正对外展示的高价值简历才占用资源。
2.  **开发体验**：本地开发几乎不需要配置 Blob Token，因为只要不点分享，流程就全是本地的。

### 劣势与风险

1.  **跨设备丢失风险**：在“编辑阶段”，如果用户在 A 电脑上传了头像（且因 Base64 过大未存入 DB），回到家由 B 电脑打开，**头像会丢失**。
    - _缓解措施_：前端必须严格限制上传图片大小（如 < 100KB）以确保 Base64 能存入数据库；或者提示用户“草稿状态头像仅本地可见”。
2.  **分享等待**：点击分享按钮时，会增加 1-2 秒的上传等待时间。

---

## 4. 代码改造指引

### 4.1 后端 Server Action

新增 `lib/actions/publish-avatar.action.ts`，专门处理 Base64 转 Blob 的逻辑。

```typescript
'use server'

import { put } from '@vercel/blob'
import { auth } from '@/auth' // 假设有 auth

export async function uploadBase64Avatar(base64Data: string, userId: string) {
  // 1. 解析 Base64
  // data:image/jpeg;base64,/9j/4AAQSkZJRg...
  const matches = base64Data.match(/^data:([A-Za-z-+\/]+);base64,(.+)$/)
  if (!matches || matches.length !== 3) {
    throw new Error('Invalid input string')
  }

  const contentType = matches[1] // e.g., image/jpeg
  const buffer = Buffer.from(matches[2], 'base64')

  // 2. 生成文件名
  const extension = contentType.split('/')[1] || 'jpg'
  const filename = `avatars/${userId}/${Date.now()}.${extension}`

  // 3. 上传到 Vercel Blob
  const blob = await put(filename, buffer, {
    access: 'public',
    contentType,
  })

  return { success: true, url: blob.url }
}
```

### 4.2 前端改造 (ShareDialog)

在 `components/resume/share/ShareResumeDialog.tsx` (假设文件名) 中注入逻辑：

```tsx
const handleShare = async () => {
  setIsSharing(true)
  try {
    let currentPhotoUrl = resumeData.basics.photoUrl

    // 检查是否需要上传
    if (currentPhotoUrl?.startsWith('data:image')) {
      toast.loading('正在优化头像资源...')

      const result = await uploadBase64Avatar(currentPhotoUrl, userId)

      if (result.success) {
        currentPhotoUrl = result.url
        // 更新本地 Store 和 数据库
        updateResumeData('basics.photoUrl', currentPhotoUrl)
        await saveResumeToDb({
          ...resumeData,
          basics: { ...resumeData.basics, photoUrl: currentPhotoUrl },
        })
      }
    }

    // 继续原本的分享逻辑 (生成 Key, 设置权限等)
    await generateShareLink()
  } catch (error) {
    toast.error('分享准备失败，请重试')
  } finally {
    setIsSharing(false)
  }
}
```

---

## 5. 总结

此方案在**用户体验**（主要是多设备编辑）和**运营成本**之间做了一个折中。

- 如果项目处于早期，且预算敏感，**强烈推荐此方案**。
- 随着项目成熟，若发现“跨设备丢失头像”的用户投诉增加，可再平滑迁移到“上传即存储”方案。
