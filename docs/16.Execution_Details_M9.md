`job_match` 是我们**最复杂的用户场景**，它包含了（可能的）**OCR 任务链**，以及从“轮询”到“流式”的**混合握手**。

对用户焦虑 的洞察（“图片转文字 ing → ... → 流式返回”）是 M9 成功的关键。

---

### M9 落地指南 (致 Agentic Coder)

**里程碑目标**：构建 `Workbench` 的“新建服务”功能，实现 `job_match`（Step 1）的完整端到端流程。这包括：

1.  **UI**：构建 `Workbench` 的“空状态” 和“状态机” UI。
2.  **后端**：实现 `createServiceAction`，能正确处理“文本”和“图片”两种输入源。
3.  **Workers**：**扩展** M6 的 Worker，使其能处理 `job_summary`、`job_match`，并**新建** `ocr-worker`。
4.  **握手**：实现 M6 定义的“**轮询 -\> 流式**”混合握手。

---

#### 任务 1：(AI IDE) 升级 M4 `task-router.ts`

- **目标**：为 M9 的 `OCR` 任务（`job_vision`）添加路由。
- **文件**：`lib/llm/task-router.ts`
- **动作 (AI IDE)**：**覆盖**此文件。
- **(代码见 M6 最终修正版 的 `任务 1`，M6 已完成，此任务跳过)**

---

#### 任务 2：(AI IDE) 创建 `Workbench` 核心状态机 (UI/UX)

- **目标**：创建一个 `Zustand` store (遵循 Rule 7.2) 来管理 `Workbench` 的复杂 UI 状态，以**缓解用户焦虑**。
- **文件**：`lib/stores/workbench.store.ts`

<!-- end list -->

```typescript
// AI IDE: Create this file at lib/stores/workbench.store.ts
import { create } from 'zustand'
import { AsyncTaskStatus } from '@prisma/client'

// 规范: 定义 M9 复杂任务链 的所有 UI 状态
export type WorkbenchStatus =
  | 'IDLE' // 1. 空闲
  | 'OCR_PENDING' // 2. 图像识别中
  | 'SUMMARY_PENDING' // 3. 岗位提取中
  | 'MATCH_PENDING' // 4. 匹配队列中
  | 'MATCH_STREAMING' // 5. 流式返回中
  | 'COMPLETED' // 6. 已完成
  | 'FAILED' // 7. 失败

interface WorkbenchState {
  // 状态管理
  currentServiceId: string | null
  status: WorkbenchStatus
  errorMessage: string | null

  // SSE 流式响应
  streamingResponse: string

  // 动作
  startTask: (serviceId: string, initialStatus: WorkbenchStatus) => void
  setStatus: (status: WorkbenchStatus) => void
  appendStreamToken: (token: string) => void
  completeStream: () => void
  setError: (message: string) => void
  reset: () => void
}

export const useWorkbenchStore = create<WorkbenchState>((set) => ({
  currentServiceId: null,
  status: 'IDLE',
  errorMessage: null,
  streamingResponse: '',

  startTask: (serviceId, initialStatus) =>
    set({
      currentServiceId: serviceId,
      status: initialStatus,
      errorMessage: null,
      streamingResponse: '',
    }),
  setStatus: (status) => set({ status }),
  appendStreamToken: (token) =>
    set((state) => ({
      status: 'MATCH_STREAMING', // 确保在收到 token 时状态正确
      streamingResponse: state.streamingResponse + token,
    })),
  completeStream: () => set({ status: 'COMPLETED' }),
  setError: (message) => set({ status: 'FAILED', errorMessage: message }),
  reset: () =>
    set({
      currentServiceId: null,
      status: 'IDLE',
      errorMessage: null,
      streamingResponse: '',
    }),
}))
```

---

#### 任务 3：(AI IDE) 创建 `Workbench` 页面 (UI)

- **目标**：构建 `Workbench` 的“空状态” UI (`/workbench`) 和“结果” UI (`/workbench/[serviceId]`)。
- **文件 3.1**：`app/[locale]/workbench/layout.tsx` (M9 布局)
- **AI IDE 动作**：创建 M9/M10 共享的“两列布局”。
  - (AI IDE: 请实现 `Sidebar` (包含 `HistoryList` Server Component) 和 `Main Workspace` (`children`)。严格遵循 M3 设计规范。)
- **文件 3.2**：`app/[locale]/workbench/page.tsx` (M9 默认页)
- **AI IDE 动作**：创建“新建服务”页面。它只做一件事：加载 `NewServiceForm` 客户端组件。
- **文件 3.3**：`components/app/NewServiceForm.tsx` (M9 核心 UI)
- **AI IDE 动作**：创建核心的“新建服务”表单。

<!-- end list -->

```typescript
// AI IDE: Create this file at components/app/NewServiceForm.tsx
'use client'
import { useState, useTransition } from 'react'
import { useRouter } from 'next/navigation'
import { useWorkbenchStore } from '@/lib/stores/workbench.store' // M9.2
import { createServiceAction } from '@/lib/actions/service.actions' // M9.4
import { Locale } from '@/i18n-config'

// (导入 M3 组件: AppCard, Button, Textarea, Input, Alert, Progress, Loader2, etc.)
// (导入 M8 Hook: useTaskPolling)
// (导入 M9 Hook: useSseStream) // M9.6 将创建

export function NewServiceForm({
  locale,
  dict,
  hasResume, // (M8 依赖)
}: {
  locale: Locale
  dict: any // i18n 字典
  hasResume: boolean
}) {
  const router = useRouter()
  const [isPending, startTransition] = useTransition()
  const [file, setFile] = useState<File | null>(null)

  // M9.2 状态机
  const { status, setStatus, startTask, setError } = useWorkbenchStore()

  // ... (M9.5 此处将添加 useTaskPolling 和 useSseStream) ...

  const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault()
    if (!hasResume) {
      toast.error(dict.prerequisiteError)
      return
    }

    const formData = new FormData(event.currentTarget)
    const text = formData.get('jd_text') as string
    const image = formData.get('jd_image') as File

    if (!text && (!image || image.size === 0)) {
      toast.error(dict.inputError)
      return
    }

    startTransition(async () => {
      // (M9.4) 调用 Server Action
      const result = await createServiceAction({ formData, locale })

      if (result.success && result.serviceId) {
        // (M9.2) 启动状态机
        startTask(result.serviceId, result.status)
        // (M9.5) 启动轮询或 SSE
        // ...
        // (UX) 跳转到新的 Service 页面
        router.push(`/${locale}/workbench/${result.serviceId}`)
      } else {
        // (UX) 五态：Failed
        setError(result.error || 'Unknown error')
      }
    })
  }

  // 规范：渲染“空状态”
  if (!hasResume) {
    return (
      <AppCard className="text-center">
        <AppCardContent>
          <Alert variant="default" className="text-left">
            <AlertTitle>{dict.prerequisite.title}</AlertTitle>
            <AlertDescription>{dict.prerequisite.description}</AlertDescription>
          </Alert>
          <Button
            onClick={() => router.push(`/${locale}/profile`)}
            className="mt-4"
          >
            {dict.prerequisite.button}
          </Button>
        </AppCardContent>
      </AppCard>
    )
  }

  // 规范：渲染“五态” - Idle
  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      <AppCard>
        <AppCardHeader>
          <AppCardTitle>{dict.title}</AppCardTitle>
          <AppCardDescription>{dict.description}</AppCardDescription>
        </AppCardHeader>
        <AppCardContent className="space-y-4">
          <Textarea
            name="jd_text"
            placeholder={dict.placeholderText}
            rows={10}
            disabled={isPending}
          />
          <div className="text-center text-sm text-muted-foreground">
            {dict.or}
          </div>
          <Input
            name="jd_image"
            type="file"
            accept="image/*"
            disabled={isPending}
            onChange={(e) => setFile(e.target.files?.[0] || null)}
          />
        </AppCardContent>
        <AppCardFooter>
          <Button type="submit" disabled={isPending}>
            {isPending ? <Loader2 className="animate-spin" /> : dict.button}
          </Button>
        </AppCardFooter>
      </AppCard>
    </form>
  )
}

// AI IDE: M9.5 将创建 `app/[locale]/workbench/[serviceId]/page.tsx`
// 这个文件将负责**读取** `useWorkbenchStore` 的状态，并渲染 M9 的“五态” UI
// (e.g., `<StatusCard status={status} response={streamingResponse} />`)
```

---

#### 任务 4：(AI IDE) `createServiceAction` (M9.4)

- **目标**：实现 M9 的“指挥塔” Server Action，它必须**串联** M1-M8 的所有基建。
- **文件**：`lib/actions/service.actions.ts` (新建)

<!-- end list -->

```typescript
// AI IDE: Create this file at lib/actions/service.actions.ts
'use server';
import { z } from 'zod';
import { revalidatePath } from 'next/cache';
import { withAuth } from '@/lib/auth/wrapper'; // M2
import { db } from '@/lib/prisma';
import * as quotaDAL from '@/lib/dal/quotas'; // M2
import { getTaskRouting, getJobVisionTaskRouting } from '@/lib/llm/task-router'; // M4
import { incrementQueueCounter } from '@/lib/kv/counter'; // M6
import { pushTaskToQueue, QStashPayload } from '@/lib/queue/producer'; // M6
import { trackEvent } from '@/lib/analytics'; // M7
import { parsePdfFromFormData } from '@/lib/utils/file-processor'; // M8
import { Locale } from '@/i18n-config';
import { WorkbenchStatus } from '@/lib/stores/workbench.store'; // M9.2

const actionSchema = z.object({
  formData: z.instanceof(FormData),
  locale: z.custom<Locale>(),
});

type ActionInput = z.infer<typeof actionSchema>;
type ActionOutput = {
  success: boolean;
  serviceId?: string;
  status?: WorkbenchStatus;
  error?: string;
  isFree?: boolean;
};

// M9 核心 Action
export const createServiceAction = withAuth(
  async (input: ActionInput, user): Promise<ActionOutput> => {

    // 1. (M8) 前置检查：资产必须就绪
    const resume = await db.resume.findFirst({
      where: { userId: user.id, status: 'COMPLETED' },
    });
    if (!resume) {
      return { success: false, error: 'ResumeNotReady' };
    }
    const detailedResume = await db.detailedResume.findFirst({
      where: { userId: user.id, status: 'COMPLETED' },
    });

    const { formData, locale } = input;
    const jdText = formData.get('jd_text') as string | null;
    const jdImage = formData.get('jd_image') as File | null;
    const isImageUpload = !!(jdImage && jdImage.size > 0);

    // 2. (M4) 获取路由
    const matchRouting = getTaskRouting('job_match', true); // (先假设付费)
    const summaryRouting = getTaskRouting('job_summary', true);
    const visionRouting = getJobVisionTaskRouting(true);

    // 3. (M2) 金币检查
    // 规范：复杂任务链 必须一次性扣费
    const cost = isImageUpload
      ? 3 // (OCR + Summary + Match)
      : 2; // (Summary + Match)
    const hasQuota = await quotaDAL.checkBalance(user.id, cost);
    const { isFree } = !hasQuota;

    // 4. (M6) 检查背压
    // (AI IDE: 此处应检查所有 *即将* 使用的队列)
    // ...

    // 5. (M2) 扣费
    if (hasQuota) {
      const deductResult = await quotaDAL.deductQuota(user.id, cost);
      // ... (处理扣费失败)
    }

    // 6. (M1) 创建服务单元
    const service = await db.service.create({
      data: {
        userId: user.id,
        resumeId: resume.id,
        detailedResumeId: detailedResume?.id,
        currentStep: 'MATCH',
        // (M1) 级联创建 Job 和 Match
        job: { create: { status: isImageUpload ? 'PENDING' : 'IDLE' } },
        match: { create: { status: 'PENDING' } },
      },
      include: { job: true, match: true },
    });
    const jobId = service.job!.id;
    const matchId = service.match!.id;

    // 7. (M7) 埋点
    trackEvent(user.id, 'TASK_CREATED', {
      task: 'job_match',
      isFree: !hasQuota,
      inputType: isImageUpload ? 'image' : 'text',
    });

    // 8. (M6) QStash 任务链
    if (isImageUpload) {
      // --- 复杂任务链 (OCR) ---
      // (AI IDE: 此处需处理图片上传到 R2/S3，然后将 URL 传给 Worker)
      // (M6.3) 推送 Task A (OCR)
      const { messageId: ocrTaskId } = await pushTaskToQueue(...);
      // (M6.3) 推送 Task B (Summary), 依赖 A
      const { messageId: summaryTaskId } = await pushTaskToQueue(..., { dependsOn: ocrTaskId });
      // (M6.3) 推送 Task C (Match), 依赖 B
      await pushTaskToQueue(..., { dependsOn: summaryTaskId });

      return { success: true, serviceId: service.id, status: 'OCR_PENDING', isFree };

    } else {
      // --- 文本任务链 ---
      // (M6.3) 推送 Task B (Summary)
      const { messageId: summaryTaskId } = await pushTaskToQueue(
        getTaskRouting('job_summary', hasQuota).queueId,
        'batch-processor', // M6 Worker
        {
          taskTemplateId: 'job_summary',
          modelId: getTaskRouting('job_summary', hasQuota).modelId,
          locale,
          context: { userId: user.id, serviceId: service.id, taskId: jobId, rawText: jdText }
        }
      );
      // (M6.3) 推送 Task C (Match), 依赖 B
      await pushTaskToQueue(
        getTaskRouting('job_match', hasQuota).queueId,
        'stream-processor', // M6 Worker
        {
          taskTemplateId: 'job_match',
          modelId: getTaskRouting('job_match', hasQuota).modelId,
          locale,
          context: { userId: user.id, serviceId: service.id, taskId: matchId }
        },
        { dependsOn: summaryTaskId }
      );

      return { success: true, serviceId: service.id, status: 'SUMMARY_PENDING', isFree };
    }

    // (AI IDE: 必须补充完整的 try/catch 和事务回滚逻辑)
  }
);
```

---

#### 任务 5：(AI IDE) 升级 Workers & 实现握手

**5.1: `app/api/worker/ocr-processor/route.ts` (新建)**

- **AI IDE 动作**：创建此新 Worker，它负责：
  1.  (M6) `verifySignatureEdge`, `acquireLock`, `decrementCounter`。
  2.  (M4) 调用 M4 的 `getModel(ModelId.GLM_4_VISION)` (处理 Base64 图片)。
  3.  (M1) 将 `raw_text` 和 `status: 'COMPLETED'` 写回 `Jobs` 表。
  4.  (M7) `trackEvent('TASK_COMPLETED', { task: 'job_ocr' })`。
  5.  (M6) `releaseLock`。

**5.2: `app/api/worker/batch-processor/route.ts` (升级)**

- **AI IDE 动作**：打开 M8 已创建的 `batch-processor`，**添加** `case 'job_summary':`

  ```typescript
  // AI IDE: Add this case to the switch in batch-processor
  // ... (handler, lock, try block) ...
  // (M4) 调用 LLM
  const structuredResult = await runStructuredLlmTask(...);

  // (M1/M8) Worker 路由
  switch (taskTemplateId) {
    case 'resume_summary':
      // ... (M8 code) ...
      break;
    case 'detailed_resume_summary':
      // ... (M8 code) ...
      break;

    // --- M9 新增逻辑 ---
    case 'job_summary':
      await db.job.update({
        where: { id: taskId },
        data: {
          jobSummaryJson: structuredResult as any,
          status: 'COMPLETED',
        },
      });
      // (M1) 更新 Service 状态，触发轮询 UI 变化
      await db.service.update({
        where: { id: context.serviceId },
        data: { match: { update: { status: 'MATCH_PENDING' } } }
      });
      break;
    // --- M9 结束 ---

    case 'customize':
      // ... (M10 code) ...
      break;
  }
  // ... (M7 trackEvent, finally block) ...
  ```

**5.3: `app/api/worker/stream-processor/route.ts` (升级)**

- **AI IDE 动作**：打开 M6 的 `stream-processor` 骨架，**填充** M5 (RAG) 和 M9 的业务逻辑。

  ```typescript
  // AI IDE: Update the stream-processor handler
  // ... (imports) ...
  import { queryRag } from '@/lib/rag/retriever' // M5
  import { z } from 'zod'
  import { ZOD_SCHEMA_MAP } from '@/lib/llm/zod-schemas' // M4

  // ... (handler, lock, try block) ...

  // --- M9 新增逻辑 ---
  // 1. (M1) 获取上下文
  const service = await db.service.findUniqueOrThrow({
    where: { id: serviceId },
    include: {
      resume: true,
      detailedResume: true,
      job: true,
    },
  })
  // (AI IDE: 此处添加错误处理，确保 resume/job 已就绪)

  // 2. (M5) 调用 RAG
  const ragContext = await queryRag(
    service.job!.jobSummaryJson as string, // (简化)
    locale,
    ['match', 'match_intent'] // 规范 5.3
  )

  // 3. (M4) 准备变量
  const variables = {
    rag_context: ragContext,
    resume_summary_json: JSON.stringify(service.resume!.resumeSummaryJson),
    detailed_resume_summary_json: JSON.stringify(
      service.detailedResume?.detailedSummaryJson
    ),
    job_summary_json: JSON.stringify(service.job!.jobSummaryJson),
  }
  // --- M9 结束 ---

  let fullOutput = ''
  const stream = await runStreamingLlmTask(
    modelId as any,
    taskTemplateId,
    locale,
    variables,
    { userId, serviceId },
    {
      onStreamEnd: async (output, usage) => {
        fullOutput = output
        try {
          // (M4) 流式结束后，验证 Zod
          const zodSchema = ZOD_SCHEMA_MAP[taskTemplateId]
          const parsedResult = JSON.parse(output)
          zodSchema.parse(parsedResult) // 验证

          // (M1) 异步将完整结果写回 DB
          await db.match.update({
            where: { id: taskId },
            data: {
              status: 'COMPLETED',
              matchSummaryJson: parsedResult as any,
            },
          })

          // (M6.5) 发送“结束”信号
          await kv.publish(kvChannel, { type: 'end', data: '[DONE]' })
        } catch (e) {
          // Zod 验证失败或 JSON 解析失败
          throw new Error(`Stream validation failed: ${e.message}`)
        }
      },
    }
  )
  // ... (M6 的 KV Pub/Sub 转发逻辑) ...
  // ... (M6 的 catch 和 finally 块) ...
  ```

---

#### 任务 6：(AI IDE) `Workbench` 握手 Hooks (UI/UX)

- **目标**：创建 `useTaskPolling` (M8 已完成) 和 `useSseStream`，并更新 `Zustand` store。
- **文件 6.1**：`lib/stores/workbench.store.ts` (升级)
- **AI IDE 动作**：添加 `currentServiceId` 到 `startTask`。
- **文件 6.2**：`lib/hooks/useSseStream.ts` (新建)

<!-- end list -->

```typescript
// AI IDE: Create this file at lib/hooks/useSseStream.ts
import { useEffect } from 'react'
import { useWorkbenchStore } from '@/lib/stores/workbench.store'

/**
 * M9 握手 Hook: 连接到 M6.5 的 SSE 路由
 * @param serviceId 当前正在流式处理的 Service ID
 */
export function useSseStream(serviceId: string | null) {
  const { setStatus, appendStreamToken, completeStream, setError } =
    useWorkbenchStore()

  useEffect(() => {
    // 仅当 serviceId 存在且状态在等待流式时才连接
    if (!serviceId) return

    const source = new EventSource('/api/sse-stream')

    source.onopen = () => {
      console.log(`SSE: Connection opened for ${serviceId}`)
    }

    source.onmessage = (event) => {
      if (event.data.startsWith(':')) return // 忽略 heartbeat

      const message = JSON.parse(event.data)

      switch (message.type) {
        case 'token':
          appendStreamToken(message.data) // 握手成功！
          break
        case 'end':
          completeStream()
          source.close()
          break
        case 'error':
          setError(message.data)
          source.close()
          break
      }
    }

    source.onerror = (err) => {
      console.error('SSE Error:', err)
      setError('Stream connection failed.')
      source.close()
    }

    // Case 3: 用户关闭页面时自动断开
    return () => {
      source.close()
    }
  }, [serviceId, appendStreamToken, completeStream, setError, setStatus])
}
```
