**M8：资产流实现**是**第一个真正的全栈功能**，它将**垂直串联**我们过去七个里程碑的所有成果：

- **M1 (DB)**：写入 `Resumes` 表。
- **M2 (Auth/Quota)**：使用 `withAuth` 和 `DAL.quotas`。
- **M3 (UI)**：使用 `AppCard` 和“五态设计”。
- **M4 (LLM)**：在 Worker 中调用 `runStructuredLlmTask`。
- **M6 (Scheduler)**：使用 `QStash` 生产者、`KV` 背压/并发锁 和 `batch-processor` Worker。
- **M7 (Analytics)**：调用 `trackEvent`。

---

## M8 落地指南 (致 Agentic Coder)

**里程碑目标**：实现“资产/服务分离”架构中的“资产”端。构建 `Profile Page` UI，并实现 `Resume` / `DetailedResume` 的**异步上传**和\*\*轮询（Polling）\*\*处理流程。

**核心规范**：

- **规则**：严格遵循 `project rules`（Rule 3 Server Action, Rule 4 DAL, Rule 9 Upstash）。
- **UI/UX**：严格遵循 M3 的“设计系统”（`AppCard`）和 M7 后讨论的“交互与状态设计指南”（**五态设计**）。

---

### 任务 1：(AI IDE) 创建文件处理工具

- **目标**：创建一个（符合 Rule 5.3）的工具，用于从 Server Action 的 `FormData` 中安全地解析 PDF 文本。
- **依赖**：`pdf-parse` (AI IDE: `pnpm add pdf-parse @types/pdf-parse`)。
- **文件**：`lib/utils/file-processor.ts`

<!-- end list -->

```typescript
// AI IDE: Create this file at lib/utils/file-processor.ts
// (Based on prototype: lib/utils/file-processor.ts)
import pdf from 'pdf-parse'

const MAX_FILE_SIZE_MB = 5
const MAX_FILE_SIZE_BYTES = MAX_FILE_SIZE_MB * 1024 * 1024

/**
 * M8 任务：从 FormData 解析 PDF 文本
 * @param formData
 * @param fieldName
 * @returns
 */
export async function parsePdfFromFormData(
  formData: FormData,
  fieldName: string
): Promise<string> {
  const file = formData.get(fieldName) as File | null

  if (!file) {
    throw new Error('FileMissing: No file found in FormData.')
  }
  if (file.type !== 'application/pdf') {
    throw new Error('InvalidFileType: Only PDF files are allowed.')
  }
  if (file.size > MAX_FILE_SIZE_BYTES) {
    throw new Error(`FileSizeLimit: File exceeds ${MAX_FILE_SIZE_MB}MB limit.`)
  }

  try {
    const arrayBuffer = await file.arrayBuffer()
    const buffer = Buffer.from(arrayBuffer)
    const data = await pdf(buffer)

    if (!data.text || data.text.trim().length < 100) {
      throw new Error('InvalidPDF: PDF content is empty or too short.')
    }
    return data.text
  } catch (error) {
    console.error('[FileProcessor] PDF parsing failed:', error)
    throw new Error('PdfParseFailed: Could not read text from PDF.')
  }
}
```

---

### 任务 2：(AI IDE) 创建资产流 Server Action (The Producer)

- **目标**：创建 `uploadResumeAction` 和 `uploadDetailedResumeAction`。这是 M8 的“生产者”，它**串联**了 M2, M4, M6, M7 的所有基建。
- **文件**：`lib/actions/asset.actions.ts`

<!-- end list -->

```typescript
// AI IDE: Create this file at lib/actions/asset.actions.ts
'use server';
import { z } from 'zod';
import { revalidatePath } from 'next/cache';
import { withAuth } from '@/lib/auth/wrapper'; // M2
import { db } from '@/lib/prisma';
import * as quotaDAL from '@/lib/dal/quotas'; // M2
import { getTaskRouting } from '@/lib/llm/task-router'; // M4
import { incrementQueueCounter } from '@/lib/kv/counter'; // M6
import { pushTaskToQueue, QStashPayload } from '@/lib/queue/producer'; // M6
import { trackEvent } from '@/lib/analytics'; // M7
import { parsePdfFromFormData } from '@/lib/utils/file-processor';
import { TaskTemplateId } from '@/lib/prompts/types';
import { Locale } from '@/i18n-config';

// 严格遵循 Rule 7.3: Zod 验证输入
const assetUploadSchema = z.object({
  formData: z.instanceof(FormData),
  locale: z.custom<Locale>(),
  taskTemplateId: z.enum(['resume_summary', 'detailed_resume_summary']),
});

type AssetUploadInput = z.infer<typeof assetUploadSchema>;

// M8 核心 Action
export const uploadAssetAction = withAuth(
  async (input: AssetUploadInput, user) => {
    // 1. (M2) 确保金币账户存在
    await quotaDAL.getOrCreateQuota(user.id);

    // 2. (M4) 检查金币与获取路由
    const { taskTemplateId, locale } = input;
    const cost = 1; // 资产流任务成本固定为 1
    const hasQuota = await quotaDAL.checkBalance(user.id, cost);
    const { modelId, queueId } = getTaskRouting(taskTemplateId, hasQuota);

    // 3. (M6) 检查背压
    const MAX_QUEUE_LENGTH = hasQuota ? 100 : 20; // 付费队列长，免费队列短
    const pressureCheck = await incrementQueueCounter(queueId, MAX_QUEUE_LENGTH);
    if (!pressureCheck.success) {
      return { success: false, error: 'QueueFull', isFree: !hasQuota };
    }

    // 4. (M2) 扣费 (如果不是免费)
    if (hasQuota) {
      const deductResult = await quotaDAL.deductQuota(user.id, cost);
      if (!deductResult.success) {
        await incrementQueueCounter(queueId, -1); // 回滚背压
        return { success: false, error: 'InsufficientQuota', isFree: false };
      }
    }

    let dbRecordId: string;
    let rawText: string;

    try {
      // 5. (M8) 文件处理
      rawText = await parsePdfFromFormData(input.formData, 'assetFile');

      // 6. (M1) 写入/更新数据库 (Upsert 保证 1-to-1)
      if (taskTemplateId === 'resume_summary') {
        const resume = await db.resume.upsert({
          where: { userId: user.id },
          create: { userId: user.id, originalText: rawText, status: 'PENDING' },
          update: { originalText: rawText, status: 'PENDING' },
        });
        dbRecordId = resume.id;
      } else {
        const detailed = await db.detailedResume.upsert({
          where: { userId: user.id },
          create: { userId: user.id, originalText: rawText, status: 'PENDING' },
          update: { originalText: rawText, status: 'PENDING' },
        });
        dbRecordId = detailed.id;
      }

      // 7. (M7) 埋点
      trackEvent(user.id, 'ASSET_UPLOADED', {
        type: taskTemplateId,
        isFree: !hasQuota,
        charCount: rawText.length,
      });

      // 8. (M6) 推送 QStash 任务
      const payload: QStashPayload = {
        taskTemplateId,
        modelId,
        locale,
        context: {
          userId: user.id,
          taskId: dbRecordId, // ** 关键：将 DB ID 传给 Worker **
          queueId: queueId.toString(),
          rawText: rawText, // 传递文本，避免 Worker 再次查库
        },
      };
      await pushTaskToQueue(queueId, 'batch-processor', payload);

      // 9. (Next.js) 刷新 `Profile Page` 的 Server Component
      revalidatePath(`/${locale}/profile`);

      // 10. (UX) 立即返回，触发前端轮询
      return {
        success: true,
        isFree: !hasQuota,
        taskId: dbRecordId,
        taskType: taskTemplateId
      };

    } catch (error)_ {
      // 捕获所有错误 (文件解析、DB、QStash 推送)
      console.error(`[AssetAction Error] ${taskTemplateId}:`, error.message);
      // 回滚
      await incrementQueueCounter(queueId, -1);
      if (hasQuota) await quotaDAL.addQuota(user.id, cost); //
      return { success: false, error: error.message, isFree: !hasQuota };
    }
  }
);
```

---

### 任务 3：(AI IDE) 升级 Worker (The Consumer)

- **目标**：**填充** M6 的 `batch-processor` 骨架，使其能真正处理 `resume_summary` 和 `detailed_resume_summary` 任务。
- **文件**：`app/api/worker/batch-processor/route.ts`
- **动作 (AI IDE)**：**覆盖** M6 创建的骨架文件。

<!-- end list -->

```typescript
// AI IDE: Overwrite this file at app/api/worker/batch-processor/route.ts
import { NextResponse } from 'next/server'
import { verifySignatureEdge } from '@upstash/qstash/dist/nextjs'
import { runStructuredLlmTask } from '@/lib/llm/service' // M4
import { decrementQueueCounter } from '@/lib/kv/counter' // M6
import { acquireConcurrencyLock, releaseConcurrencyLock } from '@/lib/kv/lock' // M6
import { QStashPayload } from '@/lib/queue/producer' // M6
import { db } from '@/lib/prisma'
import { addQuota } from '@/lib/dal/quotas' // M2
import { trackEvent } from '@/lib/analytics' // M7
import { getTaskRouting } from '@/lib/llm/task-router' // M4

export const runtime = 'edge'

async function handler(request: Request) {
  const payload = (await request.json()) as QStashPayload
  const { taskTemplateId, modelId, locale, context } = payload
  const { userId, taskId, queueId, rawText } = context

  // 1. (M6) 获取并发锁
  // 规范：并发锁是基于模型 ID (e.g., 'glm-4.5-flash')
  const routing = getTaskRouting(taskTemplateId, true) // (假设并发数不区分付费/免费)
  const MAX_CONCURRENCY = 5 // (TODO: 从配置中读取)

  let lockKey: string | null = null
  const startTime = Date.now()

  try {
    const { success, lockKey: acqKey } = await acquireConcurrencyLock(
      modelId,
      MAX_CONCURRENCY
    )
    if (!success) {
      return NextResponse.json(
        { error: 'Concurrency limit reached, retrying...' },
        { status: 429 }
      )
    }
    lockKey = acqKey
    console.log(
      `[BatchWorker] Lock acquired for ${taskTemplateId} (Task ${taskId})`
    )

    // 2. (M4) 调用 LLM (非流式)
    const structuredResult = await runStructuredLlmTask(
      modelId as any,
      taskTemplateId,
      locale,
      {
        resume_text: rawText, // for 'resume_summary'
        detailed_resume_text: rawText, // for 'detailed_resume_summary'
      },
      { userId, serviceId: context.serviceId }
    )

    // 3. (M1/M8) Worker 路由：根据任务类型写回不同表
    switch (taskTemplateId) {
      case 'resume_summary':
        await db.resume.update({
          where: { id: taskId, userId: userId },
          data: {
            resumeSummaryJson: structuredResult as any,
            status: 'COMPLETED',
          },
        })
        break
      case 'detailed_resume_summary':
        await db.detailedResume.update({
          where: { id: taskId, userId: userId },
          data: {
            detailedSummaryJson: structuredResult as any,
            status: 'COMPLETED',
          },
        })
        break
      case 'customize':
        // (M10 任务)
        // ...
        break
      default:
        throw new Error(
          `[BatchWorker] Unknown taskTemplateId: ${taskTemplateId}`
        )
    }

    // 4. (M7) 埋点
    trackEvent(userId, 'TASK_COMPLETED', {
      task: taskTemplateId,
      latencyMs: Date.now() - startTime,
    })
    console.log(`[BatchWorker] Task ${taskId} completed.`)
    return NextResponse.json({ success: true })
  } catch (error) {
    const errorMessage = (error as Error).message
    console.error(`[BatchWorker] Task ${taskId} FAILED:`, errorMessage)

    // 5. 失败处理
    try {
      // (M1) 更新 DB 状态
      if (taskTemplateId === 'resume_summary') {
        await db.resume.update({
          where: { id: taskId },
          data: { status: 'FAILED' },
        })
      } else if (taskTemplateId === 'detailed_resume_summary') {
        await db.detailedResume.update({
          where: { id: taskId },
          data: { status: 'FAILED' },
        })
      }

      // (M2) 金币返还
      const cost = 1 // 资产流任务成本
      if (context.isFree === false) {
        // 仅当是付费任务时才返还
        await addQuota(userId, cost)
      }

      // (M7) 埋点
      trackEvent(userId, 'TASK_FAILED', {
        task: taskTemplateId,
        error: errorMessage,
      })
    } catch (dbError) {
      console.error(
        `[BatchWorker] CRITICAL: DB update/quota reversal failed:`,
        dbError
      )
    }

    return NextResponse.json({ error: errorMessage }, { status: 500 })
  } finally {
    // 6. (M6) 释放锁和计数器
    if (lockKey) await releaseConcurrencyLock(modelId, lockKey)
    if (queueId) await decrementQueueCounter(queueId)
    console.log(
      `[BatchWorker] Lock/Counter released for ${taskTemplateId} (Task ${taskId})`
    )
  }
}

// (M6) 验证 QStash 签名
export const POST = verifySignatureEdge(handler)
```

---

### 任务 4：(AI IDE) `Profile Page` UI & 状态管理

- **目标**：实现 M8 的前端 UI，严格遵循 M3（设计系统）和 M7 后（交互指南）的规范。
- **文件**：`app/[locale]/profile/page.tsx` (Server Component)
- **文件**：`components/app/AssetUploader.tsx` (Client Component)

**4.1: `app/[locale]/profile/page.tsx` (Server Component)**

- **AI IDE 动作**：创建 `Profile` 页面的骨架，用于**服务端**获取数据。

<!-- end list -->

```typescript
// AI IDE: Create this file at app/[locale]/profile/page.tsx
import { auth } from '@job-assistant/authkit'
import { db } from '@/lib/prisma'
import { getDictionary } from '@/lib/i18n/dictionaries' // M3
import { Locale } from '@/i18n-config'
import { redirect } from 'next/navigation'

import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs' //
import {
  AppCard,
  AppCardHeader,
  AppCardTitle,
  AppCardDescription,
  AppCardContent,
} from '@/components/app/AppCard' // M3
import { AssetUploader } from '@/components/app/AssetUploader' // M8.4.2
import { PaymentWaitlistForm } from '@/components/app/PaymentWaitlistForm' // M10

// M8 页面 (服务端获取初始数据)
export default async function ProfilePage({
  params: { locale },
}: {
  params: { locale: Locale }
}) {
  // 1. (M2) Auth 检查
  const session = await auth()
  if (!session?.userId) redirect(`/${locale}`)

  const user = await db.users_sync.findFirst({
    where: { id: session.userId, deleted_at: null },
    include: {
      quota: true,
      resumes: true,
      detailedResumes: true,
    },
  })

  if (!user) redirect(`/${locale}`)

  // 2. (M3) 获取 i18n 字典
  const dict = (await getDictionary(locale)).profile

  return (
    <main className="container max-w-4xl mx-auto py-8 px-4">
      <h1 className="text-3xl font-bold mb-6">{dict.title}</h1>

      {/* 规范 2.5.3: Tabs 布局 */}
      <Tabs defaultValue="assets" className="w-full">
        <TabsList className="grid w-full grid-cols-2">
          <TabsTrigger value="assets">{dict.tabs.assets}</TabsTrigger>
          <TabsTrigger value="billing">{dict.tabs.billing}</TabsTrigger>
        </TabsList>

        {/* M8：资产流 Tab */}
        <TabsContent value="assets" className="space-y-6 pt-6">
          {/* 规范 2.5.3：通用简历卡片 */}
          <AppCard>
            <AppCardHeader>
              <AppCardTitle>{dict.resume.title}</AppCardTitle>
              <AppCardDescription>{dict.resume.description}</AppCardDescription>
            </AppCardHeader>
            <AppCardContent>
              {/* M8 核心：交互组件 (客户端) */}
              <AssetUploader
                locale={locale}
                taskTemplateId="resume_summary"
                initialStatus={user.resumes?.status || 'IDLE'}
                initialFileName={user.resumes ? 'uploaded_resume.pdf' : null}
                dict={dict.uploader}
              />
            </AppCardContent>
          </AppCard>

          {/* 规范 2.5.3：详细履历卡片 */}
          <AppCard>
            <AppCardHeader>
              <AppCardTitle>{dict.detailed.title}</AppCardTitle>
              <AppCardDescription>
                {dict.detailed.description}
              </AppCardDescription>
            </AppCardHeader>
            <AppCardContent>
              {/* M8 核心：交互组件 (客户端) */}
              <AssetUploader
                locale={locale}
                taskTemplateId="detailed_resume_summary"
                initialStatus={user.detailedResumes?.status || 'IDLE'}
                initialFileName={
                  user.detailedResumes ? 'uploaded_detailed_resume.pdf' : null
                }
                dict={dict.uploader}
              />
            </AppCardContent>
          </AppCard>
        </TabsContent>

        {/* M10：金币 Tab */}
        <TabsContent value="billing" className="space-y-6 pt-6">
          <AppCard>
            <AppCardHeader>
              <AppCardTitle>{dict.quota.title}</AppCardTitle>
              <AppCardDescription>{dict.quota.description}</AppCardDescription>
            </AppCardHeader>
            <AppCardContent>
              <p className="text-4xl font-bold">
                {user.quota?.balance ?? 0}{' '}
                <span className="text-lg text-muted-foreground">
                  {dict.quota.coins}
                </span>
              </p>
            </AppCardContent>
          </AppCard>

          {/* M10 支付意愿收集 */}
          <PaymentWaitlistForm userEmail={user.email} dict={dict.waitlist} />
        </TabsContent>
      </Tabs>
    </main>
  )
}
```

**4.2: `components/app/AssetUploader.tsx` (Client Component)**

- **AI IDE 动作**：创建 M8 的核心 UI 交互组件，**必须**实现“五态设计”。

<!-- end list -->

```typescript
// AI IDE: Create this file at components/app/AssetUploader.tsx
'use client'
import { useState, useTransition } from 'react'
import { usePathname, useRouter } from 'next/navigation'
import { uploadAssetAction } from '@/lib/actions/asset.actions'
import { Locale } from '@/i18n-config'
import { TaskTemplateId } from '@/lib/prompts/types'
import { AsyncTaskStatus } from '@prisma/client'
import { useTaskPolling } from '@/lib/hooks/useTaskPolling' // M8.4.3

import { Button } from '@/components/ui/button' //
import { Input } from '@/components/ui/input' //
import { Progress } from '@/components/ui/progress' //
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert' //
import { Badge } from '@/components/ui/badge' //
import { toast } from 'sonner'
import { Upload, FileCheck, FileX, Loader2 } from 'lucide-react'

type UploaderStatus = AsyncTaskStatus | 'IDLE' | 'UPLOADING'

interface AssetUploaderProps {
  locale: Locale
  taskTemplateId: 'resume_summary' | 'detailed_resume_summary'
  initialStatus: UploaderStatus
  initialFileName: string | null
  dict: {
    // i18n 字典
    button: string
    buttonProcessing: string
    status: {
      pending: string
      completed: string
      failed: string
    }
    toast: {
      uploadSuccess: string
      queueFree: string
      queueError: string
      pollSuccess: string
      pollFailed: string
    }
  }
}

export function AssetUploader({
  locale,
  taskTemplateId,
  initialStatus,
  initialFileName,
  dict,
}: AssetUploaderProps) {
  const [status, setStatus] = useState<UploaderStatus>(initialStatus)
  const [fileName, setFileName] = useState<string | null>(initialFileName)
  const [isPending, startTransition] = useTransition()
  const router = useRouter() // 用于刷新 Server Component

  // M8.4.3 轮询 Hook
  const { status: pollStatus } = useTaskPolling({
    taskId:
      status === 'PENDING'
        ? taskTemplateId === 'resume_summary'
          ? 'resume'
          : 'detailed_resume'
        : null, // (简化版 taskId，M8 应使用真实 DB ID)
    taskType: taskTemplateId,
    initialStatus: initialStatus,
    onSuccess: () => {
      setStatus('COMPLETED')
      toast.success(dict.toast.pollSuccess)
      router.refresh() // 刷新 Server Component
    },
    onError: () => {
      setStatus('FAILED')
      toast.error(dict.toast.pollFailed)
      router.refresh()
    },
  })

  const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault()
    const formData = new FormData(event.currentTarget)
    const file = formData.get('assetFile') as File | null

    if (!file || file.size === 0) {
      toast.error('Please select a file to upload.')
      return
    }

    setFileName(file.name)
    setStatus('UPLOADING') // 五态: 2a. 上传中

    startTransition(async () => {
      const result = await uploadAssetAction({
        formData,
        locale,
        taskTemplateId,
      })

      if (result.success) {
        setStatus('PENDING') // 五态: 2b. 排队/轮询中
        toast.success(dict.toast.uploadSuccess)
        if (result.isFree) {
          toast.warning(dict.toast.queueFree) // 规范 2.3.0
        }
      } else {
        setStatus('FAILED') // 五态: 5. 失败态
        toast.error(result.error || dict.toast.queueError)
      }
    })
  }

  // --- M8 核心：渲染“五态” UI ---
  const renderStatus = () => {
    const currentDisplayStatus = status === 'PENDING' ? pollStatus : status

    switch (currentDisplayStatus) {
      // 3. 处理中 (轮询)
      case 'UPLOADING':
      case 'PENDING':
        return (
          <div className="space-y-2">
            <Progress value={33} className="w-full" />
            <div className="flex items-center text-sm text-muted-foreground">
              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              {fileName} - {dict.status.pending}...
            </div>
          </div>
        )
      // 4. 成功态
      case 'COMPLETED':
        return (
          <Badge variant="secondary" className="text-green-600">
            <FileCheck className="mr-2 h-4 w-4" />
            {fileName} - {dict.status.completed}
          </Badge>
        )
      // 5. 失败态
      case 'FAILED':
        return (
          <Badge variant="destructive">
            <FileX className="mr-2 h-4 w-4" />
            {fileName} - {dict.status.failed}
          </Badge>
        )
      // 1. 空闲态
      case 'IDLE':
      default:
        return null
    }
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div className="flex flex-col sm:flex-row sm:items-center gap-4">
        <Input
          id="assetFile"
          name="assetFile"
          type="file"
          accept="application/pdf"
          required
          disabled={isPending || status === 'PENDING' || status === 'UPLOADING'}
          className="flex-1"
        />
        <Button
          type="submit"
          disabled={isPending || status === 'PENDING' || status === 'UPLOADING'}
          className="w-full sm:w-auto"
        >
          {isPending || status === 'PENDING' || status === 'UPLOADING' ? (
            <Loader2 className="mr-2 h-4 w-4 animate-spin" />
          ) : (
            <Upload className="mr-2 h-4 w-4" />
          )}
          {isPending ? dict.buttonProcessing : dict.button}
        </Button>
      </div>
      <div className="h-10">{renderStatus()}</div>
    </form>
  )
}
```

**4.3: `lib/hooks/useTaskPolling.ts` (M2 任务 4 的配套 Hook)**

- **AI IDE 动作**：创建一个可复用的 React Hook 来封装 `GET /api/task-status` 的轮询逻辑。

<!-- end list -->

```typescript
// AI IDE: Create this file at lib/hooks/useTaskPolling.ts
import { useState, useEffect } from 'react'
import { AsyncTaskStatus } from '@prisma/client'

interface UseTaskPollingProps {
  taskId: string | null
  taskType: string
  initialStatus: AsyncTaskStatus | 'IDLE' | 'UPLOADING'
  onSuccess: () => void
  onError: () => void
  // 智能轮询 策略
  interval?: number // 3000ms
  maxAttempts?: number // 20 attempts (1 min)
}

export function useTaskPolling({
  taskId,
  taskType,
  initialStatus,
  onSuccess,
  onError,
  interval = 3000,
  maxAttempts = 20,
}: UseTaskPollingProps) {
  const [status, setStatus] = useState(initialStatus)
  const [attempts, setAttempts] = useState(0)

  useEffect(() => {
    // 只有在 PENDING 状态、且有 taskId 时才启动轮询
    if (status !== 'PENDING' || !taskId) {
      return
    }

    const poll = async () => {
      if (attempts >= maxAttempts) {
        console.error(`Polling timeout for task ${taskId}`)
        onError()
        return
      }

      try {
        const res = await fetch(
          `/api/task-status?taskId=${taskId}&taskType=${taskType}`
        )
        if (!res.ok) throw new Error('Failed to fetch status')

        const data = await res.json()
        const newStatus = data.status as AsyncTaskStatus

        setStatus(newStatus)
        setAttempts((prev) => prev + 1)

        if (newStatus === 'COMPLETED') {
          onSuccess()
        } else if (newStatus === 'FAILED') {
          onError()
        }
      } catch (err) {
        console.error('Polling error:', err)
        setAttempts((prev) => prev + 1) // 也计算为一次尝试
      }
    }

    // 立即执行一次，然后设置定时器
    const timerId = setInterval(poll, interval)

    // 清理函数
    return () => clearInterval(timerId)
  }, [
    status,
    taskId,
    taskType,
    interval,
    maxAttempts,
    attempts,
    onSuccess,
    onError,
  ])

  return { status }
}
```

---

**M8 交付物：**
AI IDE（我）现在已经为你提供了 M8 里程碑的全部核心产物：

1.  `lib/utils/file-processor.ts` (新建)
2.  `lib/actions/asset.actions.ts` (新建)
3.  `app/api/worker/batch-processor/route.ts` (**重构** M6 骨架)
4.  `app/[locale]/profile/page.tsx` (新建)
5.  `components/app/AssetUploader.tsx` (新建)
6.  `lib/hooks/useTaskPolling.ts` (新建)

**DoD (验收标准)**：

1.  AI IDE（或你）在本地运行 `pnpm dev`。
2.  登录后访问 `/profile`。
3.  **测试 1 (UI)**：页面必须**严格遵循** M3 的“设计系统”规范（`AppCard`, 间距, 字体）。
4.  **测试 2 (Happy Path)**：上传一个 PDF。
    - 验收：前端**立即**显示 `Progress` 状态。
    - 验收：`QStash` 收到任务，Vercel 日志显示 `batch-processor` 启动并调用 LLM。
    - 验收：`LlmUsageLog` 和 `AnalyticsEvent` 表中出现新纪录。
    - 验收：(等待轮询) 前端最终显示 `COMPLETED` `Badge`。
5.  **测试 3 (免费队列)**：(手动修改 M2 `getOrCreateQuota` 默认赠送为 0) 上传 PDF。
    - 验收：前端**必须**弹出 "金币不足，已转入免费队列" 的 `Toaster`。
6.  **测试 4 (背压)**：(手动修改 M6.2 `MAX_QUEUE_LENGTH` 为 0) 上传 PDF。
    - 验收：前端**必须**弹出 "QueueFull" 或 "当前服务忙" 的错误 `Toaster`。

## 2. 评审

## 目标

- 在不改变既有架构前提下，完善设计系统核验页以验证新主色（浅蓝）在实际交互下的可读性与对比度；
- 输出 M8（Profile Page + 资产异步上传）完整的 DOR 与实施清单，优先复用现有能力，确保与 2.1.2 的“资产/服务分离”一致；
- 引入统一的 Toaster 能力，作为后续各 phase 的非阻塞反馈基础设施。

## 设计系统增强（Gate 0 补强）

- 新增区块：Primary 可交互演示（/design-system）
  - 展示状态：默认、Hover、Focus-visible、Active、Disabled；包含带图标与纯文本两类，验证 1–2 个主按钮原则。
  - 对比度检查：在 `bg-background` 与 `bg-card` 上分别演示，确保 `primary` 与 `primary-foreground` 在浅色模式下的对比度 ≥ 4.5。
  - 交互可视：保留 `ring` 焦点样式；禁用态降低饱和且文本可读。
  - 文案来源：全部取自字典（`getDictionary(locale)`）。
  - 验收：在设计系统页一次性过上述状态；如对比度不足，调参 `--primary` 或 `--primary-foreground`。

## Toaster 能力（非阻塞反馈）

- 方案：采用 `sonner` 封装为 `Toaster` 与 `use-toast`，全局在 `app/layout.tsx` 挂载，位置 `bottom-right`，默认时长 2.5s。
- 文案与语义：统一使用字典；警示类（金币不足/免费队列/背压）使用 `warning`；失败用 `error`；成功用 `success`；信息用 `info`。
- 验收：在 /design-system 的“非阻塞反馈”演示区可点击触发四类提示，确保字典驱动与可读性。

## M8 · Profile DOR（Definition of Ready）

- 页面结构（Server Component）：`app/[locale]/profile/page.tsx`
  - Tabs：Assets ｜ Billing；使用 `AppCard` 作为核心容器；所有文案来自字典。
  - 资产卡片：
    - 通用简历卡片（必选）：标题/描述 + 上传组件 + 状态 Badge（PENDING/COMPLETED/FAILED）。
    - 详细履历卡片（可选）：同上，文案强调“上下文越丰富越好”。
  - Billing 卡片（M10 预留）：当前余额 + 待上线通知表单。
- 交互组件（Client Component）：`components/app/AssetUploader.tsx`
  - 五态：Idle ｜ Queued ｜ Processing（轮询）｜ Success ｜ Failed。
  - 触发：选择 PDF 后提交；立即显示上传中（UPLOADING）→ 返回 success 后进入 PENDING 并启动轮询（调用 `GET /api/task-status`）。
  - 反馈：
    - `isFree === true` → `toast.warning('金币不足，已转入免费队列')`；
    - 背压/队列满 → `toast.error('当前服务忙，请稍候再试')`；
    - 完成 → `toast.success('简历解析完成')`。
  - 无阻塞：按钮在 UPLOADING/PENDING 期间 disabled；禁用态可视。
- Server Actions（Producer）：复用 + 统一
  - 现有：`lib/actions/resume.actions.ts:10–34` 与 `lib/actions/resume.actions.ts:36–60` 已具备串联能力（Auth/Quota/Upsert/Push/Analytics）。
  - 计划：保留两函数对外接口不变；抽取公共内部函数（避免重复），后续 `AssetUploader` 按任务类型选择调用（resume ｜ detailed）。
- 文件解析
  - 复用：`lib/utils/file-processor.ts:189` 的 `processUploadedFile`；从 `FormData` 提取文件后解析文本，返回 `content/metadata/hash`（支持 PDF 文本/扫描件、文本、图片）。
  - 约束：限制大小与类型，错误走友好提示（字典）。
- Worker（Consumer）
  - 现有草稿：`docs/12.Execution_Details_M8.md` 中 `batch-processor` 路由逻辑；按任务写回 `status` 与 `*_summary_json`，失败返还金币并埋点。
  - 计划：在 M6 基础上完成 resume/detailed 两类消费；释放并发锁与背压计数。
- 轮询 Hook
  - 新建：`lib/hooks/useTaskPolling.ts`，封装间隔/次数，完成与失败回调；
  - 调用：`AssetUploader` 在 PENDING 时启动。
- Analytics
  - 上传成功后：`trackEvent(userId, 'ASSET_UPLOADED', ...)`；
  - Worker 成功/失败：`TASK_COMPLETED`｜`TASK_FAILED`，含 `latencyMs`。
- i18n 与可访问性
  - 所有文本与提示从字典加载；焦点环、键盘操作可行；对比度达标；移动端 Tabs 适配。

## 实施步骤（按序）

1. 完成 `/design-system` Primary 交互演示区块与字典项；自测浅蓝对比度与焦点态。
2. 整合 Toaster 能力（封装 + 全局挂载）；在设计系统页验证四种提示。
3. 输出 Profile DOR 文档（结构/组件/状态/文案/i18n/移动端/五态映射/Toaster 触发点）。
4. 实现 `AssetUploader`（五态 + 轮询）；接入 `resume.actions.ts` 两函数；解析用 `file-processor.ts`。
5. 完成 `task-status` API 与轮询 Hook；Worker 覆盖写回逻辑与失败返还；埋点。
6. Gate 1 评审：对照 DOR 与五态清单过一遍；视觉/可访问性/移动端检查。
7. DoD 验收（3.Execution_Plan M8）：新用户上传 →Toast + Polling→Badge COMPLETED→Quota 正确；严禁硬编码文案。

## 风险与取舍

- shadcn CLI Toast 资源不稳定：优先采用 `sonner`（更稳定，更轻易全局挂载）。如将来需要替换为 `shadcn/ui` Toast，保留 `use-toast` 适配层，可平滑切换。
- 文件解析与大文件：超过阈值走扫描件通道（供视觉模型）；提示用户分辨率与大小限制。

## 时间线（建议）

- Day 1：设计系统增强 + Toaster 集成；提交 Profile DOR。
- Day 2：资产页 UI 与 `AssetUploader` 五态 + 轮询；串联现有 Actions；
- Day 3：Worker 完成与 E2E 自测；Gate 1 评审；进入 DoD 验收。

## 验收标准（对齐文档）

- 1.Project_Spec.md:39–44、128–173 的资产分离与验收条件严格满足；
- 2.Solution_Spec.md:39–71、374–424 的资产流流程与前端反馈到位；
- 2.Solution_Spec.md:915–1231 的 UI/UX 规范（spacing、color、typography、五态、移动端）在 Profile 页完全落地；
- 3.Execution_Plan.md:135–148 的 M8 DoD 场景通过；
- 12.Execution_Details_M8.md 的落地草稿作为实现参考，最终以本计划为准。
