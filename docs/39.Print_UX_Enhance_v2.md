### Step 1：问题背景描述

M10 简历定制化已基本完成，目前操作流程基本能跑通，但在简历预览这个环节遭遇了瓶颈

1. 预期的“完美效果”

市面上的竞品，经常会出现在 web 视窗编排好的简历，可是实际打印到 A4 纸时却造成了不同的分行、分页效果，而且到真正打印的时候才能看到差异，效率很低且让人恼火。

1）我想在项目中提供一个“What-You-See-Is-What-You-Print”的效果，按钮入口在 toolbar，点击启用；启用后，页面将实现严格的分页视角（类似 Word），这时候能清晰看到，段落在哪里换行、页面在哪里分页，且与最终的实际打印效果完全一致

2）提供一个智能分页（Fit-to-Page）的魔法工具

- 系统中已经有几个调整空间感的操控手段，包括：
  a) 自动分页柔性化:默认保护“标题”和“第一行内容”不分离，其余允许自然换行
  b) 紧凑模式：成比例地缩小全局间距
  c) 样式菜单下的行间距/段落间距/页面边距：这些也都是全局的调节
  d) 手动指定分页：这是给到用户手动强制在某个段落后强行分页的兜底控制

- 而 Fit-To-Page，是在此基础上，给到用户的一键魔法：
  a) 循环检查每个页面
  b) 如果页面底部确实剩下了 3cm 空白（因为下一段实在切不开），或者页面底部仅遗留了一个标题（更好的效果是把它推到下一页），则“自动充满”
  c) 如果页面刚好超出了一点（有一两句话、一两个列表项，刚好排到了下一页），则“自动收缩”
  d）需要有很智能的算法机制，首先判断对哪个页面是否应当干预？然后是如何不着痕迹地进行干预（e.g. 自动微调该页所有段落的 margin-bottom 或 line-height（比如从 1.5 增至 1.6、从 1.5 降至 1.4），神不知鬼不觉地把内容“撑”满，消除空白

2. 目前的“操作流程”
   1）用户可以点击 toolbar 上的“Web/打印”开关，切换预览打印效果；也可以通过导出 PDF 调起系统默认的打印窗口，预览将要打印的效果

2）在样式菜单中，已经预埋了“智能填充”按钮

3. 核心 Gap 痛点

1）预览效果并不是我想要的 Word 分页方式、且当前分页线的位置并不准确（参考截图附件）

2）自动填充算法太傻了，我拿测试简历在多个模板下测试了，几乎都没有达到很“人性化”的调节标准；甚至在很多场景下，点了和没点的差异并不大

### 🩺 Step 2: 代码诊断

#### 1. 致命 Gap: 打印预览的“虚假繁荣”

**问题定位：**
在 `ResumePreview.tsx` 中，使用了一个简单的 CSS `linear-gradient` 来绘制 A4 纸的分隔线：

```typescript
backgroundImage: viewMode === 'print'
  ? 'linear-gradient(to bottom, #ffffff 0mm, #ffffff 297mm, #e5e5e5 297mm, #e5e5e5 307mm)'
  : 'none',

```

**为什么它不准？**

- **硬编码高度：** 你假设每一页永远是完美的 `297mm` 内容 + `10mm` 灰条。
- **忽略了物理渲染误差：** 浏览器渲染文字时，并不是严格按照 `mm` 计算的，尤其是在跨平台（Mac/Windows）字体渲染差异下。
- **没有真正的 DOM 切割：** 这只是一个背景图！它完全不知道内容有没有跨过这条线。用户看到线划在某行文字中间，但系统没有任何机制去把这行文字推下去。

#### 2. “智能填充”算法的不稳定性

**问题定位：**
你的 `useEffect` 中包含了一个非常脆弱的 `measure` 逻辑：

```typescript
// 试图通过调整 autoScale 来凑整数页
if (decimalPart > 0 && decimalPart < 0.15) { ... }

```

**风险：**

- **无限循环 (Oscillation)：** 修改 `autoScale` 会触发重绘 -> 高度变化 -> 再次触发 `measure` -> 计算出新的 `autoScale`。虽然你加了 `0.01` 的阈值，但在边界情况下（比如刚好卡在临界点），屏幕会疯狂闪烁。
- **维度单一：** 只调节了 `lineHeight` 和 `spacing`，而且是通过全局 CSS 变量暴力缩放。这会导致本来排版很好的 Header 也被莫名其妙拉伸或压缩。

#### 3. 缺失的“强制换行”机制

**问题定位：**
`StructureOutline.tsx` 里虽然有 `hasPageBreak` 的视觉标记（小剪刀图标），但这似乎只是读取了 `sectionConfig.pageBreaks` 数据，并没有在 `ResumePreview` 中真正产生一个“垫片 (Spacer)”。

---

### 🕵️‍♂️ Step 3 Part 1: 专家深度分析 (Feasibility & Architecture)

要实现以上描绘的 Word 级体验和智能填充，我们需要突破浏览器的“黑盒”限制。

#### 1. 关于 "What-You-See-Is-What-You-Print" (WYSIWYG)

**现状痛点分析：**
目前的“打印预览”可能只是简单的去掉了 UI 边框，但依然是“长网页流”。用户只有在调用系统打印（Ctrl+P）的那一瞬间，才知道浏览器会把内容切在哪里。截图 `image_1ea71b.jpg` 显示标题在页底、内容在下一页，这是典型的 CSS `break-inside` 控制力度不够，或者容器高度计算偏差。

**可行性方案：虚拟分页 (Virtual Pagination)**

要做成 Word 那样一页一页的效果，单纯靠 CSS 是不够的，需要 React 介入计算。

- **技术路线：**

1. **容器模拟：** 在预览模式下，不再渲染一个长 `div`，而是渲染数组 `[Page1, Page2, Page3]`。每个 Page 固定 `width: 210mm; height: 297mm;`。
2. **内容切割（难点）：** \* _方案 A (完美但极难):_ 将简历内容打散成原子（一行文字、一个列表项），逐个填充到 Page 1，满了填 Page 2。这需要重写渲染引擎，成本极高。

- _方案 B (视觉模拟 - 推荐):_ 依然渲染长列表，但在 UI 上覆盖一个 `absolute` 定位的“分页遮罩层”或者使用 CSS `column` 技术模拟分页。
- _方案 C (基于预计算的 DOM 切割 - 高性价比):_ 维护一个隐藏的计算容器，计算出哪些 Section 应该在第几页，然后通过 `marginTop` 或 `Spacer` 将其强行推到下一页的视觉容器中。

**结论：** 完全模拟 Word 的**物理切割**（方案 A）在 Web 端非常重。建议采用 **“长卷轴 + 精确分页线 + 强制换行垫片”** 的方式。即：用户依然在一个长画布上编辑，但系统会精确画出 A4 截止线，且这些线的位置与打印完全一致。

#### 2. 关于 "Fit-to-Page" (智能填充魔法)

**现状痛点分析：**
截图显示“智能填充”效果不明显。这通常是因为算法是线性的（例如：只是把 margin 从 24px 减到 20px），没有形成**闭环反馈**。

**可行性方案：迭代求解器 (Iterative Layout Solver)**

这其实是一个数学优化问题。

- **算法逻辑：**

1. **定义变量：** 全局缩放系数 `S` (影响字号)、行高系数 `L`、段间距系数 `M`。
2. **定义目标：** 内容总高度 `H` 必须 `N * 297mm - 底部留白`。
3. **求解过程 (Binary Search)：**

- **Step 1:** 渲染一次，测量总高度。
- **Step 2:** 发现剩 3cm 空白。
- **Step 3:** 增大系数 `L` 和 `M`（比如 +5%）。
- **Step 4:** 再次隐式渲染，测量高度。
- **Step 5:** 如果溢出了，回退一点；如果还不够，再加一点。
- **Step 6:** 找到最优解，应用到界面。

- **技术挑战：**
- **性能：** React 重新渲染并测量 DOM 是昂贵的。如果不小心，用户点击按钮后浏览器会卡死 1-2 秒。
- **收敛性：** 有可能怎么调都调不满（比如剩半页），算法需要有“放弃阈值”。

#### 3. 关于 Gap 的根源：DPI 陷阱

为什么你说“预览线位置不准”？

- **原因：** 屏幕通常是 96 DPI 或更高（Retina），而打印也是独立的 DPI。CSS 中的 `mm` 单位在屏幕渲染和打印驱动渲染中存在微小的 **抗锯齿/舍入误差**。
- **解法：** 必须统一使用 `pt` (Points) 作为核心单位，或者在计算高度时引入 `Epsilon` (容错值)。

---

感谢你提供的代码，这对我进行精准诊断至关重要。

通过深入分析 `ResumePreview.tsx`, `useResumeTheme.ts` 和 `StructureOutline.tsx`，我发现我们目前的实现与“所见即所得 (WYSIWYG)”之间确实存在巨大的鸿沟，而且你之前的“智能填充”逻辑 (`Fit-to-Page`) 在 React 的 `useEffect` 中写得过于简陋，存在严重的震荡风险。

现在，我们进入 **Step 2: 专家会诊与架构验证**。

---

### 🏗️ Step 3 Part 2: 可行性架构方案 (Architecture Proposal)

为了实现以上的目标，设计了一套基于 **"Virtual Page Container" (虚拟分页容器)** 的新架构。

#### 核心思路：

不再渲染一个无限长的 `div`，而是利用 React 的计算能力，在预览模式下渲染一组 `<A4Page />` 组件。

**流程图解：**

1. **Measurement Phase (测量阶段):**

- 先在一个不可见的容器中渲染完整的“长卷轴”简历。
- 获取每个 Block (Section/Item) 的真实高度 `offsetHeight`。

2. **Pagination Logic (分页算法):**

- 执行一个纯 JS 函数 `computePages(blocks, 297mm)`。
- 它会模拟堆叠：
- `currentHeight + blockHeight > 297mm`?
- Yes -> 结束当前页，开启新页，把 Block 放进新页。
- No -> 继续堆叠。

- **Fit-to-Page 魔法接入点：** 在这里判断，如果最后一页高度 < 50%，尝试调整前几页的 `spacing` 参数重新计算。

3. **Rendering Phase (渲染阶段):**

- 输出数组：`pages = [[Header, Summary], [Exp1, Exp2], [Exp3...]]`。
- React 遍历这个数组，渲染 `N` 个 `<div className="w-[210mm] h-[297mm]">`。

**可行性评估：**

- **复杂度：** 高 (需要重写渲染循环)。
- **准确度：** 极高 (WYSIWYG 达到 99%)。
- **性能：** 中等 (测量阶段会有一次 Layout Thrashing，但对于简历这种数据量完全可控)。

---

### ⚠️ 妥协方案 (High ROI Alternative)

完全重写渲染循环可能工期太大。如果想在**现有代码结构**上以最小成本实现最大效果，更推荐 **"Spacer-Based" (垫片法)**。

**原理：**
依然渲染长卷轴，但根据计算结果，在需要分页的地方插入一个 `<div style={{ height: 'X mm' }} />`，强行把后面的内容推到下一个背景图的“白纸区域”。

---

### Step 4: Step-By-Step 落地指南

这是一个非常有挑战性但也极具价值的工程探索。感谢你提供了如此完整的代码上下文，特别是 `InteractiveSection` 和 `resume-store` 的实现细节，这让我可以给出一个真正“手术刀”级别的落地指南。

既然你已经实现了手动分页符的数据流和 CSS 打印控制，我们的核心任务就剩下一个：**在 Web 预览的长卷轴上，利用“垫片 (Spacer)”精准模拟出分页效果，实现 WYSIWYG。**

以下是为您定制的 **Step-by-Step 落地指南 (The Spacer Method)**。

---

### 🛠️ 核心思路：The Virtual Spacer Engine

1. **测量 (Measure)**：获取每个区块（`InteractiveSection`）的真实高度。
2. **模拟 (Simulate)**：在内存中模拟 A4 纸的堆叠过程。

- 如果遇到 **手动分页符** -> 插入垫片，强行填满当前页剩余空间。
- 如果遇到 **自然跨页** -> 插入垫片，将该区块整体推到下一页起始处。

3. **渲染 (Render)**：

- 将计算出的 `marginTop` 应用到各个区块。
- 在背景中绘制绝对定位的“分页线 (Page Divider)”，模拟物理纸张边界。

---

### Phase 1: 基础设施准备 (Infrastructure)

首先，我们需要一个专门的 Hook 来处理复杂的计算逻辑。

#### 1. 新建 `hooks/use-resume-layout.ts`

这个 Hook 负责测量和计算垫片高度。

```typescript
import { useState, useLayoutEffect, useCallback } from 'react'
import { useResumeStore } from '@/store/resume-store'

// A4 纸物理规格 (96 DPI)
// 297mm * 3.7795 px/mm ≈ 1122.5px
// 为了防止浏览器打印时的舍入误差导致多出一页，我们稍微保守一点，使用 1122px
const PAGE_HEIGHT_PX = 1122
// 页面视觉间隙 (Web 预览时的灰色背景高度，打印时应忽略)
const PAGE_GAP_PX = 0 // 如果是连续纸张模式，间隙由 padding 控制，这里设为 0 简化计算

export function useResumeLayout(containerRef: React.RefObject<HTMLDivElement>) {
  const { sectionConfig, resumeData, styleConfig } = useResumeStore()
  const [spacers, setSpacers] = useState<Record<string, number>>({})
  const [totalPages, setTotalPages] = useState(1)

  // 核心计算逻辑
  const calculateLayout = useCallback(() => {
    if (!containerRef.current) return

    // 1. 获取所有 InteractiveSection 元素
    const sections = Array.from(
      containerRef.current.querySelectorAll('[data-section-id]')
    ) as HTMLElement[]

    if (sections.length === 0) return

    const newSpacers: Record<string, number> = {}
    let currentY = 0 // 当前累积高度 (相对于第一页顶部)

    // 预读取所有高度，减少重排 (Reflow)
    const measurements = sections.map((el) => {
      // 临时移除 margin-top 以获取原始高度 (Intrinsic Height)
      const originalMargin = el.style.marginTop
      el.style.marginTop = '0px'
      const height = el.getBoundingClientRect().height
      el.style.marginTop = originalMargin
      return {
        id: el.getAttribute('data-section-id')!,
        height,
        hasPageBreak: el.getAttribute('data-has-page-break') === 'true',
      }
    })

    measurements.forEach((item, index) => {
      const itemHeight = item.height
      const itemStart = currentY
      const itemEnd = itemStart + itemHeight

      // 当前所在的页面索引 (0-based)
      const startPageIndex = Math.floor(itemStart / PAGE_HEIGHT_PX)
      const endPageIndex = Math.floor(itemEnd / PAGE_HEIGHT_PX)

      let spacer = 0

      // Case A: 手动分页符 (Manual Break)
      // 如果前一个元素有分页符，当前元素必须从新的一页开始
      // 注意：逻辑上应该是“前一个元素”导致分页，所以我们在处理当前元素时，
      // 检查 currentY 是否已经是新页面的起点。
      // 这里我们在累加 currentY 时处理 Case A。

      // Case B: 自然跨页 (Auto Break)
      // 如果一个元素跨越了页界 (Start 在 Page 1, End 在 Page 2)
      // 并且它不是那种特别长（超过一页）的元素，我们把它推下去
      if (endPageIndex > startPageIndex && itemHeight < PAGE_HEIGHT_PX) {
        // 计算距离下一页顶部的距离
        const nextPageStartY = (startPageIndex + 1) * PAGE_HEIGHT_PX
        spacer = nextPageStartY - itemStart

        // 应用垫片
        newSpacers[item.id] = spacer
        currentY += spacer
      }

      currentY += itemHeight

      // 处理手动分页符逻辑：
      // 如果当前项被标记为强制分页，强行填满当前页
      if (item.hasPageBreak) {
        const currentPageEnd =
          Math.ceil(currentY / PAGE_HEIGHT_PX) * PAGE_HEIGHT_PX
        // 实际上我们不需要增加 currentY，而是不仅要告诉下一个循环“你得从新页开始”
        // 简单做法：把 currentY 推进到下一页起点
        if (currentY < currentPageEnd) {
          currentY = currentPageEnd
        }
      }
    })

    setSpacers(newSpacers)
    setTotalPages(Math.ceil(currentY / PAGE_HEIGHT_PX) || 1)
  }, [resumeData, sectionConfig, styleConfig]) // 依赖项：数据或样式变更时重算

  // 使用 useLayoutEffect 确保在浏览器绘制前计算完成，避免闪烁
  useLayoutEffect(() => {
    // 简单的防抖或延迟，确保 DOM 已经渲染
    const timer = setTimeout(calculateLayout, 50)
    return () => clearTimeout(timer)
  }, [calculateLayout])

  return { spacers, totalPages }
}
```

---

### Phase 2: 组件集成 (Integration)

我们需要修改 `InteractiveSection.tsx` 来接收 ID 和分页状态，并修改 `ResumePreview.tsx` 来应用垫片。

#### 1. 修改 `components/resume/InteractiveSection.tsx`

我们需要它把 `data-section-id` 和 `data-has-page-break` 暴露给 DOM，并支持 `style` 传入垫片高度。

```typescript
// ... imports

interface InteractiveSectionProps {
  sectionKey: string
  itemId?: string
  children: React.ReactNode
  className?: string
  style?: React.CSSProperties // 新增 style 支持
}

export function InteractiveSection({
  sectionKey,
  itemId,
  children,
  className,
  style, // 接收传入的 marginTop
}: InteractiveSectionProps) {
  const { activeSectionKey, activeItemId, setActive, sectionConfig } = useResumeStore()

  // 生成唯一 ID 用于测量
  const uniqueId = itemId ? `${sectionKey}-${itemId}` : sectionKey
  const configKey = itemId || sectionKey
  const hasPageBreak = sectionConfig.pageBreaks?.[configKey] || false

  // ... (isActive 逻辑保持不变)

  return (
    <div
      // 关键属性用于 Phase 1 的测量
      data-section-id={uniqueId}
      data-has-page-break={hasPageBreak}

      style={style} // 应用计算出的垫片高度 (marginTop)

      className={cn(
        'relative group transition-all duration-200 rounded-sm cursor-pointer border border-transparent',
        '-mx-2 px-2 py-1.5',
        isActive ? 'border-blue-500 bg-blue-50/10' : 'hover:border-gray-300 hover:bg-gray-50/50',

        // 移除旧的 .break-after-page 类，因为现在由垫片控制物理位置
        // 但为了保险起见，打印时可以保留，双重保障
        hasPageBreak && "break-after-page mb-8 border-b-2 border-dashed border-red-300 print:border-none",

        className
      )}
      onClick={(e) => { ... }}
    >
      {/* ... 编辑按钮保持不变 ... */}

      {/* 移除旧的伪元素提示，我们稍后做更高级的分页线 */}
      {children}
    </div>
  )
}

```

#### 2. 修改 `components/resume/ResumePreview.tsx`

接入 `useResumeLayout` 并渲染视觉分页线。

```typescript
// ... imports
import { useResumeLayout } from '@/hooks/use-resume-layout'

// ... ResumePreview component definition

// 定义新的分页线组件
const PageDivider = ({ pageIndex }: { pageIndex: number }) => (
  <div
    className="absolute left-0 w-full border-t border-dashed border-gray-300 pointer-events-none flex justify-between items-center px-2 z-50 no-print"
    style={{ top: `${pageIndex * 1122}px` }} // 1122px = 297mm
  >
    <div className="bg-gray-100 text-[10px] text-gray-500 px-1 rounded transform -translate-y-1/2">
      Page {pageIndex} End
    </div>
    <div className="bg-gray-100 text-[10px] text-gray-500 px-1 rounded transform -translate-y-1/2">
      Page {pageIndex + 1} Start
    </div>
    {/* 边角 ICON 装饰 */}
    <div className="absolute left-0 top-0 w-2 h-2 border-t border-l border-gray-400 -mt-[1px] -ml-[1px]" />
    <div className="absolute right-0 top-0 w-2 h-2 border-t border-r border-gray-400 -mt-[1px] -mr-[1px]" />
  </div>
)

export const ResumePreview = forwardRef<HTMLDivElement, ResumePreviewProps>(
  ({ templateId, data, config }, ref) => {
    // ... store hooks
    const paperRef = useRef<HTMLDivElement | null>(null)

    // 1. 接入布局计算 Hook
    const { spacers, totalPages } = useResumeLayout(paperRef)

    // ... dynamicStyles calculation

    // 2. 将 spacers 传递给 Template (Context 可能是更好的选择，但为了简单，这里假设我们能穿透传递)
    // 由于我们无法直接修改所有 Template 组件的内部代码来接收 props，
    // 最好的办法是创建一个 Context Provider 包裹 Template。

    return (
      <div className="origin-top transition-transform ...">
        {/* ... styles ... */}

        <div
          ref={paperRef}
          className="resume-paper relative ..." // 确保 relative 定位
          style={{
            ...dynamicStyles,
            // 强制高度以匹配分页总数，实现“长卷轴”背景
            minHeight: `${totalPages * 297}mm`,
          }}
        >
          {/* 3. 渲染上帝视角的分页线 */}
          {viewMode === 'print' &&
            Array.from({ length: totalPages - 1 }).map((_, i) => (
              <PageDivider key={i} pageIndex={i + 1} />
            ))}

          {/* 4. 使用 Context 将 spacers 传递给深层的 InteractiveSection */}
          <SpacerContext.Provider value={spacers}>
            {data ? renderTemplate(data) : <div>No Data</div>}
          </SpacerContext.Provider>
        </div>
      </div>
    )
  }
)
```

#### 3. 补全 Context 链路

新建 `components/resume/SpacerContext.tsx`:

```typescript
import { createContext, useContext } from 'react'

const SpacerContext = createContext<Record<string, number>>({})

export const useSpacer = (id: string) => {
  const spacers = useContext(SpacerContext)
  return spacers[id] || 0
}

export { SpacerContext }
```

然后回到 `InteractiveSection.tsx`，使用这个 Hook：

```typescript
import { useSpacer } from './SpacerContext'

export function InteractiveSection({ ... }) {
  // ... uniqueId generation
  const spacerHeight = useSpacer(uniqueId)

  return (
     <div
       style={{
         marginTop: spacerHeight ? `${spacerHeight}px` : undefined, // 应用垫片
         ...style
       }}
       // ...
     />
  )
}

```

---

### Phase 3: 打印 CSS 修正 (The Final Polish)

为了确保浏览器打印时不会因为我们加了 `marginTop` 而产生混乱（比如 `marginTop` + 浏览器自动分页 = 双重分页），我们需要在 `globals.css` 中做最后微调。

```css
@media print {
  /* 关键策略：
     WYSIWYG 意味着我们希望浏览器打印出我们在 Web 上看到的“长图”。
     因为我们已经精确计算了 1122px 一页，并且用 spacers 填补了空白，
     理论上浏览器应该能完美地在每 1122px 处自然分页。
  */

  /* 隐藏所有视觉辅助元素 */
  .no-print {
    display: none !important;
  }

  /* 确保垫片在打印时依然占据空间 */
  div[style*='margin-top'] {
    display: block !important;
  }

  /* 移除红色的虚线分页符提示，因为我们已经用真实距离推开了 */
  .break-after-page {
    border-bottom: none !important;
    margin-bottom: 0 !important;
  }

  /* 强制背景色打印 (Chrome) */
  body {
    -webkit-print-color-adjust: exact;
  }
}
```

### 总结

这套 **Spacer Method** 的核心优势在于：

1. **所见即所得**：你在 Web 上看到的灰色分页线在哪里，打印出来就一定在哪里。
2. **兼容手动控制**：用户手动插入的分页符会被计算引擎识别，转化为一个巨大的 `marginTop` 垫片，强行把内容推到下一页。
3. **视觉反馈**：`PageDivider` 组件提供了你想要的“上帝视角”和“边角 ICON”。
