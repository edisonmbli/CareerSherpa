generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
  engineType      = "library"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  schemas  = ["neon_auth", "public"]
}

model users_sync {
  raw_json         Json
  id               String            @id @default(dbgenerated("(raw_json ->> 'id'::text)"))
  name             String?           @default(dbgenerated("(raw_json ->> 'display_name'::text)"))
  email            String?           @default(dbgenerated("(raw_json ->> 'primary_email'::text)"))
  created_at       DateTime?         @default(dbgenerated("to_timestamp((trunc((((raw_json ->> 'signed_up_at_millis'::text))::bigint)::double precision) / (1000)::double precision))")) @db.Timestamptz(6)
  updated_at       DateTime?         @db.Timestamptz(6)
  deleted_at       DateTime?         @db.Timestamptz(6)
  analyticsEvents  AnalyticsEvent[]
  coinTransactions CoinTransaction[]
  detailedResumes  DetailedResume?
  paymentWaitlists PaymentWaitlist?
  quota            Quota?
  resumes          Resume?
  services         Service[]

  @@index([deleted_at])
  @@map("users_sync")
  @@schema("neon_auth")
}

model Quota {
  id        String     @id @default(cuid())
  userId    String     @unique @map("user_id")
  balance   Int        @default(0)
  createdAt DateTime   @default(now()) @map("created_at")
  updatedAt DateTime   @default(now()) @updatedAt @map("updated_at")
  user      users_sync @relation(fields: [userId], references: [id], onDelete: Cascade, map: "quota_user_id_fkey")

  @@map("quotas")
  @@schema("public")
}

model PaymentWaitlist {
  id        String     @id @default(cuid())
  userId    String     @unique @map("user_id")
  email     String
  createdAt DateTime   @default(now()) @map("created_at")
  user      users_sync @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("payment_waitlist")
  @@schema("public")
}

model Resume {
  id                String          @id @default(cuid())
  userId            String          @unique @map("user_id")
  originalText      String?         @map("original_text")
  resumeSummaryJson Json?           @map("resume_summary_json")
  status            AsyncTaskStatus @default(PENDING)
  createdAt         DateTime        @default(now()) @map("created_at")
  updatedAt         DateTime        @default(now()) @updatedAt @map("updated_at")
  user              users_sync      @relation(fields: [userId], references: [id], onDelete: Cascade, map: "resume_user_id_fkey")
  services          Service[]

  @@map("resumes")
  @@schema("public")
}

model DetailedResume {
  id                  String          @id @default(cuid())
  userId              String          @unique @map("user_id")
  originalText        String?         @map("original_text")
  detailedSummaryJson Json?           @map("detailed_summary_json")
  status              AsyncTaskStatus @default(PENDING)
  createdAt           DateTime        @default(now()) @map("created_at")
  updatedAt           DateTime        @default(now()) @updatedAt @map("updated_at")
  user                users_sync      @relation(fields: [userId], references: [id], onDelete: Cascade, map: "detailed_resume_user_id_fkey")
  services            Service[]

  @@map("detailed_resumes")
  @@schema("public")
}

model Service {
  id                 String            @id @default(cuid())
  userId             String            @map("user_id")
  resumeId           String            @map("resume_id")
  detailedResumeId   String?           @map("detailed_resume_id")
  currentStep        ServiceStep       @default(MATCH) @map("current_step")
  createdAt          DateTime          @default(now()) @map("created_at")
  updatedAt          DateTime          @default(now()) @updatedAt @map("updated_at")
  currentStatus      ExecutionStatus   @default(IDLE) @map("current_status")
  executionSessionId String?           @map("execution_session_id")
  failureCode        FailureCode?      @map("failure_code")
  lastUpdatedAt      DateTime?         @map("last_updated_at")
  coinTransactions   CoinTransaction[]
  customizedResume   CustomizedResume?
  interview          Interview?
  job                Job?
  match              Match?
  user               users_sync        @relation(fields: [userId], references: [id], onDelete: Cascade, map: "service_user_id_fkey")
  detailedResume     DetailedResume?   @relation(fields: [detailedResumeId], references: [id])
  resume             Resume            @relation(fields: [resumeId], references: [id], onDelete: Cascade)

  @@index([userId(sort: Desc), createdAt(sort: Desc)])
  @@index([currentStatus, updatedAt(sort: Desc)])
  @@map("services")
  @@schema("public")
}

model Job {
  id             String          @id @default(cuid())
  serviceId      String          @unique @map("service_id")
  originalText   String?         @map("original_text")
  originalImage  String?         @map("original_image")
  jobSummaryJson Json?           @map("job_summary_json")
  status         AsyncTaskStatus @default(PENDING)
  createdAt      DateTime        @default(now()) @map("created_at")
  updatedAt      DateTime        @default(now()) @updatedAt @map("updated_at")
  imageUrl       String?         @map("image_url")
  service        Service         @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@map("jobs")
  @@schema("public")
}

model Match {
  id               String          @id @default(cuid())
  serviceId        String          @unique @map("service_id")
  matchSummaryJson Json?           @map("match_summary_json")
  status           AsyncTaskStatus @default(PENDING)
  createdAt        DateTime        @default(now()) @map("created_at")
  updatedAt        DateTime        @default(now()) @updatedAt @map("updated_at")
  service          Service         @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@map("matches")
  @@schema("public")
}

model CustomizedResume {
  id                   String          @id @default(cuid())
  serviceId            String          @unique @map("service_id")
  status               AsyncTaskStatus @default(PENDING)
  createdAt            DateTime        @default(now()) @map("created_at")
  updatedAt            DateTime        @default(now()) @updatedAt @map("updated_at")
  degradeReason        String?         @map("degrade_reason")
  markdown_text        String?
  ops_json             Json?
  optimizeSuggestion   String?         @map("optimize_suggestion")
  customizedResumeJson Json?           @map("customized_resume_json")
  editedResumeJson     Json?           @map("edited_resume_json")
  sectionConfig        Json?           @map("section_config")
  service              Service         @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@map("customized_resumes")
  @@schema("public")
}

model Interview {
  id                String          @id @default(cuid())
  serviceId         String          @unique @map("service_id")
  interviewTipsJson Json?           @map("interview_tips_json")
  status            AsyncTaskStatus @default(PENDING)
  createdAt         DateTime        @default(now()) @map("created_at")
  updatedAt         DateTime        @default(now()) @updatedAt @map("updated_at")
  service           Service         @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@map("interviews")
  @@schema("public")
}

model KnowledgeEntry {
  id        String                 @id @default(cuid())
  content   String
  embedding Unsupported("vector")?
  lang      String
  source    String?
  category  String?
  isPublic  Boolean                @default(true) @map("is_public")
  createdAt DateTime               @default(now()) @map("created_at")
  updatedAt DateTime               @updatedAt @map("updated_at")
  title     String?

  @@index([lang, category, isPublic])
  @@map("knowledge_entries")
  @@schema("public")
}

model AnalyticsEvent {
  id        String      @id @default(cuid())
  userId    String?     @map("user_id")
  eventName String      @map("event_name")
  payload   Json?
  createdAt DateTime    @default(now()) @map("created_at")
  user      users_sync? @relation(fields: [userId], references: [id])

  @@index([eventName, createdAt(sort: Desc)])
  @@index([userId, createdAt(sort: Desc)])
  @@map("analytics_events")
  @@schema("public")
}

model LlmUsageLog {
  id             String       @id @default(cuid())
  modelName      String?      @map("model_name")
  inputTokens    Int          @default(0) @map("input_tokens")
  outputTokens   Int          @default(0) @map("output_tokens")
  cost           Float?       @default(0)
  createdAt      DateTime     @default(now()) @map("created_at") @db.Timestamptz(6)
  errorMessage   String?      @map("error_message")
  isStream       Boolean      @default(false) @map("is_stream")
  isSuccess      Boolean      @default(true) @map("is_success")
  latencyMs      Int          @map("latency_ms")
  modelId        String       @map("model_id")
  provider       String
  serviceId      String?      @map("service_id")
  taskTemplateId String       @map("task_template_id")
  totalTokens    Int          @default(0) @map("total_tokens")
  userId         String?      @map("user_id")
  errorCode      FailureCode? @map("error_code")

  @@index([userId, createdAt(sort: Desc)])
  @@index([taskTemplateId, createdAt(sort: Desc)])
  @@index([serviceId, createdAt(sort: Desc)])
  @@map("llm_usage_logs")
  @@schema("public")
}

model CoinTransaction {
  id           String            @id @default(cuid())
  userId       String            @map("user_id")
  type         CoinTxnType
  status       CoinTxnStatus
  delta        Int               @map("delta")
  balanceAfter Int               @map("balance_after")
  serviceId    String?           @map("service_id")
  taskId       String?           @map("task_id")
  templateId   String?           @map("template_id")
  messageId    String?           @map("message_id")
  idemKey      String?           @unique @map("idem_key")
  relatedId    String?           @map("related_id")
  metadata     Json?
  createdAt    DateTime          @default(now()) @map("created_at")
  related      CoinTransaction?  @relation("RelatedLedger", fields: [relatedId], references: [id])
  refunds      CoinTransaction[] @relation("RelatedLedger")
  service      Service?          @relation(fields: [serviceId], references: [id])
  user         users_sync        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)])
  @@index([taskId, createdAt(sort: Desc)])
  @@index([serviceId, createdAt(sort: Desc)])
  @@map("coin_transactions")
  @@schema("public")
}

enum AsyncTaskStatus {
  PENDING
  COMPLETED
  FAILED

  @@schema("public")
}

enum ServiceStep {
  MATCH
  CUSTOMIZE
  INTERVIEW
  COMPLETED

  @@schema("public")
}

enum ExecutionStatus {
  IDLE
  JOB_VISION_PENDING
  JOB_VISION_FAILED
  JOB_VISION_COMPLETED
  OCR_PENDING
  OCR_FAILED
  OCR_COMPLETED
  SUMMARY_PENDING
  SUMMARY_FAILED
  SUMMARY_COMPLETED
  PREMATCH_PENDING
  PREMATCH_FAILED
  PREMATCH_COMPLETED
  MATCH_PENDING
  MATCH_STREAMING
  MATCH_FAILED
  MATCH_COMPLETED
  CUSTOMIZE_PENDING
  CUSTOMIZE_FAILED
  CUSTOMIZE_COMPLETED
  INTERVIEW_PENDING
  INTERVIEW_FAILED
  INTERVIEW_COMPLETED

  @@schema("public")
}

enum FailureCode {
  PREVIOUS_OCR_FAILED
  PREVIOUS_SUMMARY_FAILED
  PREVIOUS_MODEL_LIMIT
  JSON_PARSE_FAILED
  ZOD_VALIDATION_FAILED
  ENQUEUE_FAILED
  PROVIDER_NOT_CONFIGURED
  MODEL_TOO_BUSY
  STREAM_EMPTY
  LLM_LOGIC_REFUSAL
  TEMPLATE_LEAKAGE
  EMPTY_RESPONSE

  @@schema("public")
}

enum CoinTxnType {
  SIGNUP_BONUS
  PURCHASE
  SERVICE_DEBIT
  FAILURE_REFUND
  MANUAL_ADJUST

  @@schema("public")
}

enum CoinTxnStatus {
  PENDING
  SUCCESS
  FAILED
  REFUNDED

  @@schema("public")
}
